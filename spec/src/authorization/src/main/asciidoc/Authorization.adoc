:sectnums:
= Jakarta Authorization Specification, Version 1.5

Copyright (c) 2013, 2019 Oracle and/or its affiliates. All rights reserved.

Oracle and Java are registered trademarks of Oracle and/or its 
affiliates. Other names may be trademarks of their respective owners. 

=== Preface

 

=== Status of Document

This document is the Final Release of the
Java _TM_ Authorization Contract for Containers Version 1.5
specification and represents the definition of this technology as
implemented by the reference implementation (RI) and verified by the
technology compatibility kit (TCK) . This specification was developed
under the Java Community Process (JCP2.7).

=== Audience

This document is intended for developers of
the RI and TCK and for those who will be delivering implementations of
this technology in their products.

=== Abstract

This specification defines new
java.security.Permission classes to satisfy the Java EE authorization
model. The specification defines the binding of container access
decisions to operations on instances of these permission classes. The
specification defines the semantics of policy providers that employ the
new permission classes to address the authorization requirements of Java
EE, including the following:

* the definition of roles as named
collections of permissions
* the granting to principals of permissions
corresponding to roles
* the determination of whether a principal
has been granted the permissions of a role (e.g. isCallerInRole)
* the definition of identifier to role
mappings that bind application embedded identifiers to application
scoped role names.

The specification defines the installation
and configuration of authorization providers for use by containers. The
specification defines the interfaces that a provider must make available
to allow container deployment tools to create and manage permission
collections corresponding to roles.

=== Keywords

The keywords “MUST”, “MUST NOT”, “REQUIRED”,
“SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and
“OPTIONAL” in this document are to be interpreted as described in
RFC2119 [KEYWORDS].

=== Acknowledgements

This draft of the specification incorporates
the contributions of the RI and TCK teams with the output of the JSR115
Expert Group. The JSR 115 Expert Group included the following members:



Steven Bazyl RSA Security, Inc.

Sean Dolan Hitachi Computer Products

Herb Erickson SilverStream Software

Gary Ellison Sun Microsystems

Neil Forrest Dyoti Enterprises Ltd

Johan Gellner Tmax Soft, Inc.

Craig Heath Individual

Hal Lockhart Entegrity Solutions

Larry McCay Hewlett-Packard Company

Serge Mister Entrust, Incorporated

Ron Monzillo Sun Microsystems

Anthony Nadalin Tivoli Systems, Incorporated

Nataraj Nagaratnam International Business
Machines Corporation

Vijakumar Natarajan Borland Software
Corporation

Raymond K. Ng Oracle Corporation

Samir Nigam Sybase, Incorporated

Henry Pasternack Netegrity, Incorporated

Paul Patrick BEA Systems

Francis Pouatcha Individual

Jyri Virkki iPlanet



The RI, the TCK, and the improvements to the
specification made as a result of the experiences gained during these
actvities are the result of the fine work of the following individuals:



Jean-Francois Arcand Sun Microsystems

Carla Carlson Sun Microsystems

Shing Wai Chan Sun Microsystems

Paul Hendley Sun Microsystems

Kumar Jayanti Sun Microsystems

Eric Jendrock Sun Microsystems

Jagadesh Babu Munta Sun Microsystems

Tony Ng Sun Microsystems

Craig Perez Oracle America, Inc.

Raja Perumal Sun Microsystems

Deepa Singh Sun Microsystems

Harpreet Singh Sun Microsystems

Nithya Subramanian Sun Microsystems



The following people are among many who
commented on the specification, and in so doing, contributed to its
final form. I would like to recognize the contributions of everyone who
commented on the specification.



Rajeev Angal iPlanet

Lambert Boskamp SAP AG

William Cox BEA Systems

Paul Ferwerda BEA Systems

Charlie Lai Sun Microsystmes

Rosanna Lee Sun Microsystems

Robert Naugle Hewlett-Packard Company

Bob Scheifler Sun Microsystems

Bill Shannon Sun Microsystems

Neil Smithline BEA Systems

Sirish Vepa Sybase, Incorporated

Kai Xu Sun Microsystems

== CHAPTER 1 - 

Overview

This specification defines a contract between
Java EE containers and authorization policy modules such that container
authorization functionality can be provided as appropriate to suit the
operational environment.

=== Introduction

The contract defined by this specification is
divided into three subcontracts. Taken together, these subcontracts
describe the installation and configuration of authorization providers
such that they will be used by containers in performing their access
decisions. The three subcontracts are the
link:jacc.html#a173[See Provider Configuration Subcontract],
the link:jacc.html#a232[See Policy Configuration Subcontract],
and the link:jacc.html#a556[See Policy Decision and Enforcement
Subcontract].



image:authz-1.png[image]

=== [[a76]]Policy Configuration and Enforcement Subcontracts

=== Terminology

=== Java EE application

A collection of Java EE modules that must
share a common principal-to-role-mapping

=== deploy (e.g. an application)

 The sequence of operations comprised of
completing the declaration of an application or module’s dependencies on
container facilities, binding the declared dependencies to specific
mechanisms or features of an operational environment, installing or
distributing the application software and related configuration
information to one or more application servers, and activating the
software such that it is available to service requests.

=== undeploy (e.g. an application)

The combined process of stopping an
application and then removing the software and configuration information
corresponding to the application or a module of the application from one
or more application servers.

=== redeploy (e.g. a module of an application)

The repackaging of an application or module
to accommodate modification of implementation and or of declared
dependencies and or of the binding of declared dependencies to
mechanisms, combined with undeploying a corresponding module or
application, followed by redistribution and activation of the modified
software and or configuration.

=== grant

The act of assigning to entities the right to
perform a set of activities that is the subject of an authorization
decision (that is, a permission).

=== hostname

The name of a logical host of an application
server, as may be used in the composition of a servlet policy context
identifier.

=== [[a90]]JAAS Policy interface

 The _javax.security.auth.Policy_ abstract
class.

=== [[a92]]JAAS Policy provider

 An instance of a class that implements the
JAAS Policy interface.

=== permission

Represents a set of activities (a set of one
or more operations on some set of one or more resources) that is the
target of an authorization decision.

=== Policy Context

The collection of policy statements within a
policy provider that effect access to the resources of one or more
deployed modules.

=== Policy Context Identifier

A unique string value that identifies the
collection of policy statements corresponding to a policy context within
a policy provider.

=== policy statement

A representation of the circumstances under
which the set of activities represented by a permission are to be
authorized.

=== excluded policy statement

A representation of the decision not to
authorize a set of activities represented by a permission independent of
factors that might otherwise effect the outcome of the decision.

=== unchecked policy statement

A representation of the decision to authorize
a set of activities represented by a permission independent of factors
that might otherwise effect the outcome of the decision.

=== principal

[1] (Java) A security attribute acquired as a
result of authentication by entities that perform activities.

[2] An entity that performs activities.

=== principal-to-role mapping

The act of granting to principals the set of
permissions that comprise a role.

=== privilege

 A security attribute that may be assigned to
entities and that may be used to differentiate an entity’s right to
perform activities.

=== Provider

The software component that contains
implementations of the policy configuration, and policy decision classes
defined by this specification.

=== reference-to-role mapping

The component-scoped transformation of
component embedded role aliases into application-scoped role names. The
transformation is defined at application deployment and perhaps modified
by policy management.

=== role

[1] A named set of permissions that may be
granted to principals.

[2] A principal that has been granted
permissions or that is used as a privilege.

=== [[a120]]Assumptions

The contract defined in this JSR must be
applicable to both J2EE 1.3 platforms and J2EE 1.4 platforms and to
future versions of the Java EE platform.

We are defining a contract to be satisfied by
“standard” Java SE Policy providers. In a J2EE 1.3 context we expect the
provider to include a JAAS Policy provider.

J2EE 1.4 platforms will be required to
implement the contract defined by this JSR. This contract will be a
required element of subsequent versions of the Java EE platform.

Support for the contract by J2EE 1.3
platforms is optional. It is expected that there may be aspects of the
contract that are Java EE release specific.

We do not expect to add new decision
interfaces to Policy (JAAS or Java SE) to accomplish the work of this
JSR.

Java EE application roles will be modeled as
collections of permissions that are granted to principals.

A principal that is in a role is granted all
the permissions of the collection. However, the converse is not true.
That is, a principal that has been granted all the permissions of a role
is not necessarily in the role (as determined by isCallerInRole()).

This contract will shift the responsibility
for performing all of the authorization decisions pertaining to a Java
EE application to the policy provider. Accordingly, the following
mappings will become the responsibility of the provider.

* permissions to roles
* principals to roles
* (Application embedded) role references to
role names

It is assumed that there are providers that
are unable to enumerate all the permissions that pertain to a
subject/protection domain before returning from Policy.getPermissions().

Any interfaces that this contract defines to
be used by containers and or container deployment tools to create policy
statements within a policy provider must be compatible with a
module-at-a- time application deployment mechanism.

Where the Enterprise JavaBeansTM (EJBTM) or
Java ServletTM specifications are incomplete or ambiguous in their
specification of authorization functionality, the contract defined in
this document may require additional semantics. Additional or clarifying
semantics will only be adopted by this specification based on their
acceptance by the spec lead and expert group of the corresponding
component specification.

The EJB policy decisions performed by
providers may require access to the arguments of the EJB invocation and
or (for entity beans) the container managed EJB instance state.

=== [[a136]]Requirements

This contract must support providers that are
unable to determine, before returning from Policy.getPermissions(), all
the permissions that pertain to a subject/protection domain.

Each Policy provider that satisfies this
contract must perform or delegate to another provider all the permission
evaluations requested via its interface in the JRE; not just those made
by the container to implement Java EE security functionality.

Each provider must export interfaces (defined
by this contract) for use by containers and or container deployment
tools to create policy statements within the policy store of the
provider. These interfaces must be used when an application or module is
deployed in a container.

Each provider must satisfy all of the
authorization requirements of the EJB and Servlet specifications
corresponding to the target platform. The provider is not required to
satisfy the authorization requirements pertaining to any of the above
specifications for which the target platform is not a compatible
implementation.

The evaluation of a permission corresponding
to a resource must identify the context of the resource's use such that
different policy can be applied to a resource used in different contexts
(that is, applications or instances of an application).

In the case of Servlet resources, the
provider must be able to associate a distinct policy context with each
context root (including context roots created to support virtual
hosting) hosted by the server.

In protecting Servlet resources, a provider
must select the policy statements that apply to a request according to
the constraint matching and servlet mapping rules defined by the Servlet
specification.

To support this contract in a Servlet
environment, a container or its deployment tools must create policy
statements as necessary to support Servlet’s “default role-ref
semantic”.

For a container to support this contract, it
must execute in an environment controlled by a Java SE SecurityManager.
Containers may also execute in environments that are not controlled by a
Java SE SecurityManager. link:jacc.html#a154[See Running
Without a SecurityManager] defines changes to this contract that apply
to containers running without a Java SE SecurityManager.

Policy providers must perform the permission
evaluations corresponding to container pre-dispatch decisions and
application embedded privilege tests (i.e isUserInRole and
isCallerInRole) without requiring that containers establish particular
values for any of the non-principal attributes of the one or more
java.security.ProtectionDomain objects that are the subject of the
evaluation.

=== Non Requirements

This JSR does not require that containers
support server-side authentication module plug-ins for the purpose of
populating subjects with authorization provider specific principals.

This JSR does not require that subjects be
attributed with role principals as a result of authentication.

This JSR does not define or mandate a
specific policy language to be used by providers. Each provider must
define its own syntax, mechanisms, and administrative interfaces for
granting permissions to principals.

The JSR does not require that providers
support a policy syntax for granting to principals roles as collections
of permissions.

Although the JSR is focused on defining
permissions and policy for use by Java EE containers, we make no
restrictions on the use of this information by other containers or
applications, or on support by containers or providers of other
permissions or policy.

It is not the intent of this JSR to extend or
modify the Java EE authorization model to be equivalent to standard RBAC
models for access control.

=== [[a154]] Running Without a SecurityManager

The following list defines changes to this
contract that apply to containers running without a Java SE
SecurityManager.

The restrictions defined in
link:jacc.html#a549[See Permission to Configure Policy] need
not be enforced. Also, the containers of the application server must not
be denied permission to perform any operation that would have been
permitted in the presence of a SecurityManager.

Such containers are not required (before
dispatching a call) to associate an AccessControlContext with the call
thread (as otherwise required by link:jacc.html#a569[See
Pre-dispatch Decision] and link:jacc.html#a616[See EJB
Pre-dispatch Decision]).

When performing the operations defined in
link:jacc.html#a727[See Checking AccessControlContext
Independent Grants] and in link:jacc.html#a736[See Checking the
Caller for a Permission], such containers must not employ the
SecurityManager.checkPermission techniques defined in these sections.

When using the
AccessController.checkPermission technique of
link:jacc.html#a736[See Checking the Caller for a Permission],
the calling container must ensure that the principals of the caller are
contained in the AccessControlContext associated with the thread on
which the call to checkPermission is made.

=== [[a160]]Servlet or EJB only containers

The requirements of this specification that
must be satisfied by a target platform that is a compatible
implementation of one but not both of the Servlet and EJB specifications
are reduced as described in the next two sections.

=== Servlet Only Containers

A platform that is a compatible
implementation of the Servlet specification and that is not a compatible
implementation of the EJB specification must satisfy all of the
requirements of this specification with the following exceptions:

{empty}the policy configuration requirements
defined in link:jacc.html#a512[See EJB Policy Context
Identifiers] and in link:jacc.html#a516[See Translating EJB
Deployment Descriptors]

{empty}the policy enforcement requirements
defined in link:jacc.html#a614[See Policy Enforcement by EJB
Containers] and link:jacc.html#a622[See Provider Support for
EJB Policy Enforcement]

{empty}the policy context handler
requirements defined in link:jacc.html#a719[See SOAPMessage
Policy Context Handler], and link:jacc.html#a723[See
EnterpriseBean Policy Context Handler], and
link:jacc.html#a725[See EJB Arguments Policy Context Handler]

=== EJB Only Containers

A platform that is is a compatible
implementation of the EJB specification and that is not a compatible
implementation of the Servlet specification must satisfy all of the
requirements of this specification with the following exceptions:

{empty}the policy configuration requirements
defined in link:jacc.html#a271[See Servlet Policy Context
Identifiers] and in .link:jacc.html#a276[See Translating
Servlet Deployment Descriptors]

{empty}the policy enforcement requirements
defined in link:jacc.html#a558[See Policy Enforcement by
Servlet Containers] and link:jacc.html#a574[See Provider
Support for Servlet Policy Enforcement]

{empty}the policy context handler
requirements defined in .link:jacc.html#a721[See
HttpServletRequest Policy Context Handler]

== CHAPTER 2 - 

[[a173]]Provider Configuration
Subcontract

The link:jacc.html#a173[See Provider
Configuration Subcontract] defines the requirements placed on providers
and containers such that Policy providers may be integrated with
containers.

=== [[a175]]Policy Implementation Class

The contract defined by this specification
has been designed to work in J2SE 1.4 or later Java Standard Edition
environments with the default _java.security.Policy_ implementation
class, and in J2SE 1.3 environments with the default
_javax.security.auth.Policy_ _implementation class. Support for the
contract defined by this specification is optional in J2EE 1.3
environments._

Java platforms provide standard security
properties whose values may be defined to cause replacement of the
default system Policy implementation classes. The security property, “
_policy.provider_ ”, may be used to replace the default
_java.security.Policy_ implementation class. Similarly, the security
property, " _auth.policy.provider_ ", may be used to replace the default
_javax.security.auth.Policy_ implementation class. These properties are
defined in the Java security properties file, and replacement is
accomplished by setting their value to the fully qualified name of the
desired Policy implementation class. The contract defined in this
specification, is dependent on the Policy replacement mechanisms of the
target Java environment. An application server that supports this
contract must allow replacement of the top level java.security.Policy
object used by every JRE of the containers of the application server.

=== Permission Implementation Classes

This contract defines a Java standard
extension package, j _avax.security.jacc,_ that contains (among other
things) Permission classes to be used by containers in their access
decisions.

=== Policy Configuration Interface

The _javax.security.jacc_ package defines an
abstract factory class that implements a static method _that uses a
system property_ to find and instantiate a provider specific factory
implementation class. The abstract factory class is
_javax.security.jacc.PolicyConfigurationFactory_ , the static method is
_getPolicyConfigurationFactory,_ _and the system property is_
_javax.security.jacc.PolicyConfigurationFactory.provider_ .

The abstract factory class also defines an
abstract public method used to create or locate instances of the
provider specific class that implements the interface used to define
policy contexts within the associated Policy provider. The method is
_getPolicyConfiguration_ and the interface is
_javax.security.jacc.PolicyConfiguration_ .

 _The abstract_ _PolicyConfigurationFactory_
class and the _PolicyConfiguration_ _interface_ are defined in
link:jacc.html#a760[See API]. Use of the _PolicyConfiguration_
interface is defined in link:jacc.html#a232[See Policy
Configuration Subcontract].

=== [[a184]]PolicyContext Class and Context Handlers

This _javax.security.jacc_ package defines a
utility class that is used by containers to communicate policy context
identifiers to Policy providers. The utility class is
_javax.security.jacc.PolicyContext_ , and this class implements static
methods that are used to communicate policy relevant context values from
containers to Policy providers. Containers use the static method
_PolicyContext.setContextID_ to associate a policy context identifier
with a thread on which they are about to call a decision interface of a
Policy provider. Policy providers use the static method
_PolicyContext.getContextID_ to obtain the context identifier
established by a calling container. The role of policy context
identifiers in access decisions is described in
link:jacc.html#a253[See Policy Contexts and Policy Context
Identifiers]”.

In addition to the methods used to
communicate policy context identifiers, the
_javax.security.jacc.PolicyContext_ class also provides static methods
that allow container specific context handlers that implement the
_javax.security.jacc.PolicyContextHandler_ interface to be registered
with the _PolicyContext_ class. The _PolicyContext_ class also provides
static methods that allow Policy providers to activate registered
handlers to obtain additional policy relevant context to apply in their
access decisions.

The _PolicyContext_ utility class and the
_PolicyContextHandler_ i _nterface_ are defined in
link:jacc.html#a760[See API]. Use of the _PolicyContext_ class
is defined in link:jacc.html#a232[See Policy Configuration
Subcontract].

=== What a Provider Must Do

Each JRE of an application server must be
provided with classes that implement the _PolicyConfigurationFactory_
_class and_ _PolicyConfiguration_ _interface. These classes must be_
compatible with the Policy implementation class installed for use by the
JRE. In the case where the provider is not seeking to replace the Policy
implementation used by the JRE, no other components need be provided.

If the provider is seeking to replace the
Policy implementation used by the JRE, then the JRE must be provided
with an environment specific Policy implementation class. If the JRE is
running a J2SE 1.4 or later Java Standard Edition environment, then it
must be provided with an implementation of the _java.security.Policy_
class. If the JRE is running a J2SE 1.3 security environment, it must be
provided with an implementation of the _javax.security.auth.Policy_
class (that is, a JAAS Policy object).

A replacement Policy object must assume
responsibility for performing all policy decisions within the JRE in
which it is installed that are requested by way of the Policy interface
that it implements. A replacement Policy object may accomplish this by
delegating non- _javax.security.jacc_ policy decisions to the
corresponding default system Policy implementation class. A replacement
Policy object that relies in this way on the corresponding default
Policy implementation class must identify itself in its installation
instructions as a “delegating Policy provider”.

The standard security properties mechanism
for replacing a default system Policy implementation (see
link:jacc.html#a175[See Policy Implementation Class]) should
not be used to replace a default system Policy provider with a
delegating Policy provider.

=== Optional Provider Support for JAAS Policy Object

In J2SE 1.4, the subject based authorization
functionality of the JAAS Policy interface has been integrated into
_java.security.Policy_ , and the JAAS Policy interface (as a separate
entity) has been deprecated. This does not mean that the JAAS Policy
interface was removed, but rather that the essential parts of it have
been tightly integrated into the J2SE 1.4 platform.

According to this contract, a J2SE 1.4 or
later Java Standard Edition security environment may support replacement
of the JAAS Policy object if and only if all javax.security.jacc policy
decisions performed by the replacement JAAS Policy object return the
same result as when the java.security.Policy interface is used. To
satisfy this requirement, the replacement JAAS Policy object must be
compatible with the implementations of _PolicyConfigurationFactory_
_and_ _PolicyConfiguration_ _interface provided for use with the
java.security.Policy implementation class._

=== [[a196]]What the Application Server Must Do

An application server or container must
bundle or install the _javax.security.jacc_ standard extension. This
package must include the abstract
_javax.security.jacc.PolicyConfigurationFactory_ class, the
_javax.security.jacc.PolicyConfiguration_ and
_javax.security.jacc.PolicyContextHandler_ interfaces, and
implementations of the _javax.security.jacc.PolicyContextException_
exception, _the javax.security.jacc_ Permission classes, and the
javax.security.jacc.PolicyContext utility class. The Permission classes
of the _javax.security.jacc_ package are:

*  _javax.security.jacc.EJBMethodPermission_
*  _javax.security.jacc.EJBRoleRefPermission_
* 
_javax.security.jacc.WebResourcePermission_
*  _javax.security.jacc.WebRoleRefPermission_
* 
_javax.security.jacc.WebUserDataPermission_

To enable delegation of non-
_javax.security.jacc_ policy decisions to default system Policy
providers, all application servers must implement the following Policy
replacement algorithm. The intent of the algorithm is to ensure that
Policy objects can capture the instance of the corresponding default
system Policy object during their integration into a container and such
that they may delegate non-container policy evaluations to it.

For each JRE of a J2EE 1.4 or later version
Java EE application server, if the system property
_“javax.security.jacc.policy.provider_ ” is defined, the application
server must construct an instance of the class identified by the system
property, confirm that the resulting object is an instance of
_java.security.Policy,_ and set, by calling the
_java.security.Policy.setPolicy_ method, the resulting object as the
corresponding Policy object used by the JRE. For example:

===  String javaPolicy = System.getProperty(

 "javax.security.jacc.policy.provider"

 );



 if (javaPolicy != null) \{

 try \{

 java.security.Policy.setPolicy(

 (java.security.Policy)

 Class.forName(javaPolicy).newInstance()

 );

 } catch (ClassNotFoundException cnfe) \{

 // problem with property value or classpath

 } catch (IllegalAccessException iae) \{

 // problem with policy class definition

 } catch (InstantiationException ie) \{

 // problem with policy instantiation

 } catch (ClassCastException cce) \{

 // Not instance of java.security.policy

 }

===  }

An application server that chooses to support
this contract in a J2SE 1.3 environment must perform the policy
replacement algorithm described above when the system property “
_javax.security.jacc.auth.policy.provider_ ” is defined. That is, for
each JRE of the application server, the server must construct an
instance of the class identified by the system property, confirm that
the resulting object is an instance of _javax.security.auth.Policy,_ and
set, by calling _javax.security.auth.Policy.setPolicy_ method _,_ the
resulting object as the corresponding Policy object used by the JRE.

Once an application server has used either of
the system properties defined in this section to replace a Policy object
used by a JRE, the application server must not use setPolicy to replace
the corresponding Policy object of the running JRE again.

The requirements of this section have been
designed to ensure that containers support Policy replacment and to
facilitate delegation to a default system Policy provider. These
requirements should not be interpreted as placing any restrictions on
the delegation patterns that may be implemented by replacement Policy
modules.

=== Modifications to the JAAS SubjectDomainCombiner

The reference implementation of the combine
method of the JAAS _SubjectDomainCombiner_ returns protection domains
that are constructed with a _java.security.Permissions_ collection.This
is the norm in J2SE 1.3 environments, and it also occurs in J2SE 1.4 and
Java Standard Edition 5.0 environments when the installed JAAS Policy
implementation class is not the _com.sun.security.auth.PolicyFile_ class
(that is, the JRE is operating in backward compatibility mode with
respect to JAAS Policy replacement). The use of
_java.security.Permissions_ by the _SubjectDomainCombiner_ forces JAAS
Policy providers to compute all the permissions that pertain to a
subject and code source and effectively precludes integration of Policy
subsystems that are not capable of doing so. To ensure that the
implementation of the JAAS _SubjectDomainCombiner_ does not preclude
integration of a class of Policy providers, this contract imposes the
following requirement and recommendation on application servers.

To satisfy the contract defined by this
specification, a J2EE 1.3 application server must install or bundle,
such that it is used by every JRE of the application server, a
_javax.security.auth.SubjectDomainCombiner_ whose _combine_ method
returns protection domains constructed using the permission collections
returned by _javax.security.auth.Policy.getPermisions_ . It is
recommended that this requirement also be satisfied by J2EE 1.4 and
later version Java EE application servers in the case where
_javax.security.auth.Policy_ is used (in backward compatibility mode) to
perform javax.security.jacc policy decisions.

== CHAPTER 3 - 

[[a232]]Policy Configuration
Subcontract

The link:jacc.html#a232[See Policy
Configuration Subcontract] defines the interactions between container
deployment tools and providers to support the translation of declarative
Java EE authorization policy into policy statements within a Java SE
Policy provider.

This subcontract also applies to the
translation of authorization policy annotations that have an equivalent
representation in Java EE deployment descriptor policy constructs (i.e.,
_security-constraint_ , _method-permission_ , _security-role-ref_ , and
_exclude-list_ elements).

=== [[a235]]What a Java EE Platform’s Deployment Tools Must Do

The _getPolicyConfigurationFactory_ method
must be used in every JRE to which the components of the application or
module are being deployed to find or instantiate
PolicyConfigurationFactory objects.

===  _PolicyConfigurationFactory pcf =_

===  _PolicyConfigurationFactory.getPolicyConfigurationFactory();_

The _getPolicyConfiguration_ method of the
factories must be used to find or instantiate _PolicyConfiguration_
objects corresponding to the application or modules being deployed.

===  _String petContextID = “acme-pet-server /petstore”_ ;

===  _PolicyConfiguration petPC =_

===  _pcf.getPolicyConfiguration(petContextID,true);_

The declarative authorization policy
statements derived from the application or module deployment
descriptor(s) must be translated to create instances of the
corresponding _javax.security.jacc_ Permission classes.

=== WebResourcePermission webPerm =

===  new WebResourcePermission(“/elephant”,“GET”);

Methods of the _PolicyConfiguration_
interface must be used with the permissions resulting from the
translation to create policy statements within the _PolicyConfiguration_
objects.

=== petPC.addToRole(“customer”,webPerm);

The _PolicyConfiguration_ objects must be
linked such that the same principal-to-role mapping will be applied to
all the modules of the application.

===  _petPC.linkConfiguration(petFoodPC);_

The PolicyConfiguration objects must be
placed in Service such that they will be assimilated into the Policy
providers used by the containers to which the application has been
deployed.

=== petPC.commit();

Independent of this specification, J2EE
deployment tools must translate and complete the declarative policy
statements appearing in deployment descriptors into a form suitable for
securing applications on the platform. On versions of the Java EE
platform that require support for authorization policy annotations, the
deployment tools must combine policy annotations in Java code with
policy statements appearing in deployment descriptors to yield complete
representations of authorization policy suitable for securing
applications on the platform. The rules for combining authorization
policy annotations with declarative policy statements are described in
the versions of the EJB, Servlet, and Java EE platform specifications
that require support for the annotations. Independent of whether
annotations factor in the translation, the resulting policy statements
may differ in form from the policy statements appearing in the
deployment descriptors. The policy translation defined by this
subcontract is described assuming that the policy statement form used by
a platform is identical to that used to express policy in the deployment
descriptors. Where this is not the case, the output of the translation
must be equivalent to the translation that would occur if policy was
completely specified in the deployment descriptors and the translation
had proceeded directly from the deployment descriptors to the Java SE
policy forms defined by this subcontract. Two translations are
equivalent if they produce corresponding collections of unchecked,
excluded, and role permissions, and if all of the permissions of each
such collection are impliedlink:#a1250[1] by the permissions of
the corresponding or excluded collection of the other translation.
Translation equivalence is only required with respect to the permission
types that are the subject of the translation.

=== [[a253]]Policy Contexts and Policy Context Identifiers

It must be possible to define separate
authorization policy contexts corresponding to each deployed instance of
a Java EE module. This per module scoping of policy context is necessary
to provide for the independent administration of policy contexts
corresponding to individual application modules (perhaps multiply
deployed) within a common Policy provider.

Each policy context contains all of the
policy statements (as defined by this specification) that effect access
to the resourceslink:#a1251[2] in one or more deployed modules.
At policy configuration, a _PolicyConfiguration_ object is created for
each policy context, and populated with the policy statements
(represented by permission objects) corresponding to the context. Each
policy context has an associated policy context identifier.

In the link:jacc.html#a556[See
Policy Decision and Enforcement Subcontract], access decisions are
performed by checking permissions that identify resources by name and
perhaps action. When a permission is checked, this specification
requires identification of the authorization policy context in which the
evaluation is to be performed (see link:jacc.html#a707[See
Setting the Policy Context]).

=== [[a257]]Policy Context Life Cycle

link:jacc.html#a268[See
PolicyConfiguration State Table] depicts the policy context life cycle
as effected through the methods of the PolicyConfiguration interface. A
policy context is in one of three states and all implementations of the
PolicyConfiguration interface must implement the state semantics defined
in this section.

*  open

A policy context in the open state must be
available for configuration by any of the methods of the
PolicyConfiguration interface. A policy context in the open state must
not be assimilated at Policy.refresh into the policy statements used by
the Policy provider in performing its access decisions.

* inService

A policy context in the inService state must
be assimilated at Policy.refresh into the policy statements used by its
provider. When a provider's refresh method is called, it must assimilate
only policy contexts that are in the inService state and it must ensure
that the policy statements put into service for each policy context are
only those defined in the context at the time of the call to refresh. A
policy context in the inService state must be unavailable for additional
configuration. A policy context in the inService state must be
transitioned to the open state when it is returned as a result of a call
to getPolicyConfiguration. A policy context is transitioned to the
inService state by calling the commit method, and only a policy context
in the open state may be transitioned to the inService state.

* deleted

A policy context in the deleted state must be
unavailable for configuration and it must be unavailable for
assimilation into its associated Provider. A policy context in the
deleted state must be transitioned to the open state when it is returned
as a result of a call to getPolicyConfiguration. A policy context is
transitioned to the deleted state by calling the delete method.



Note that for a provider implementation to be
compatible with multi-threaded environments, it may be necessary to
synchronize the refresh method of the provider with the methods of its
PolicyConfiguration interface and with the getPolicyConfiguration and
inService methods of its PolicyConfigurationFactory.



image:PolicyConfigurationStateTable.png[image]

=== [[a268]]PolicyConfiguration State Table

=== [[a269]]Linking Policy Contexts

In the Java EE security model,
principal-to-role mappings have application scope; that is, the same
principal-to-role mappings must apply in the access decisions applied at
all of the modules (that may represent separate policy contexts) that
comprise an application. Same application policy contexts must be
associated by calling the _PolicyConfiguration.linkConfiguration_
method. This method must create a transitive and symmetric relationship
within the provider and between this _PolicyConfiguration_ and the
argument _PolicyConfiguration_ , such that they and all
PolicyConfiguration objects otherwise linked to either of them share the
same principal-to-role mappings. The semantics of the association must
preserve the invariant that at most one principal-to-role mapping may
apply to any _PolicyConfiguration_ .

=== [[a271]]Servlet Policy Context Identifiers

Servlet requests may be directed to a logical
host using various physical or virtual host names or addresses, and an
application server may be composed of multiple logical hosts. A virtual
application server may be realized as a cluster of physical application
servers, each hosting some subset of the logical hosts of the virtual
application server. This specification uses the term hostname to refer
to the name of a logical host that processes Servlet requests. A servlet
container is responsible for mapping the target name or address
information of an HTTP request to the appropriate hostname.

To satisfy this specification, an application
server must establish servlet policy context identifiers sufficient to
differentiate all instances of a web application deployed on the logical
host or on any other logical host that may share the same policy
statement repository. One way to satisfy this requirement is to compose
policy context identifiers by concatenating the hostname with the
context path (as defined in the Servlet specification) identifying the
web application at the host.

When an application is composed of multiple
web modules, a separate policy context must be defined per module. This
is necessary to ensure that url-pattern based and servlet name based
policy statements configured for one module do not interfere with those
configured for another.

In Servlet containers that support the
programmatic registration and security configuration of servlets (e.g.,
Servlet 3.0 compatible Servlet containers), the policy contexts assigned
to web applications and web modules must be distinct from those to which
any EJBlink:#a1252[3] components are assigned.

=== [[a276]]Translating Servlet Deployment Descriptors

A reference to a _PolicyConfiguration_ object
must be obtained by calling the _getPolicyConfiguration_ method on the
_PolicyConfigurationFactory_ implementation class of the provider
configured into the container. The policy context identifier used in the
call to the _getPolicyConfiguration_ method must be a _String_ composed
as described in link:jacc.html#a271[See Servlet Policy Context
Identifiers]. The _security-constraint_ and _security-role-ref_ elements
in the deployment descriptor must be translated into permissions and
added to the _PolicyConfiguration_ object as defined in the following
sections. Before the translation is performed, all policy statements
must have been removedlink:#a1253[4] from the policy context
associated with the returned _PolicyConfiguration_ .

=== [[a278]]Programmatic Servlet Registrations

In Servlet containers that support the
programmatic registration and security configuration of servlets (e.g.,
Servlet 3.0 compatible Servlet containers), the servlet policy
translation defined by this subcontract is described assuming that all
such programmatic registration and security configuration has completed
(for the servlet module corresponding to the policy context) before the
translation is performed and that the resulting security related
configuration has been represented in its equivalent form within the
deployment descriptors on which the translation is performed. Where this
is not the case, the result of the translation must be equivalent, as
described previously, to the translation that would occur if it was the
case. The mapping to equivalent deployment descriptor representation of
security related configuration corresponding to programmatically
registered servlets is defined in the Servlet specification (beginning
with version 3.0).

If the results of a prior translation are
invalidated by subsequent programmatic registration and security
configuration (as might occur if an initial translation is performed
before the programmatic effects), the translation must be repeated.
Before the translation is repeated, a reference must be obtained to the
_PolicyConfiguration_ object in the open state, and its policy
statements must be removed. If the PolicyConfiguration has already been
linked to other committed policy contexts, then it may be necessary or
preferable (in order to satisfy the linking requirements defined in
link:jacc.html#a527[See Deploying an Application or Module]”)
to obtain the reference and remove the policy statements while
preserving the linkages established for the context by the prior
translation. Policy statements may be removed while preserving linkages
by calling the _removeUncheckedPolicy_ , _removeExcludedPolicy_ , and
_removeRole_ methods on the open _PolicyConfiguration_ object.

=== [[a281]]Translating security-constraint Elements

 _The paragraphs of this section describe the
translation of security-constraints into WebResourcePermission and
WebUserDataPermission objects constructed using qualified URL pattern
names. In the exceptional case, as defined in
link:jacc.html#a288[See Qualified URL Pattern Names]”, where a
pattern is made irrelevant by a qualifying pattern, the permission
instantiations that would result from the translation of the pattern, as
described below, must not be performed. Otherwise, the translation of
URL patterns in security constraints must yield an equivalent
translation to the translation that would result from following the
instructions in the remainder of this section._

 _A WebResourcePermission and a
WebUserDataPermissionlink:#a1254[5] object must be added to the
excluded policy statements for each distinct_ _url-pattern_ _occurring
in the_ _security-constraint_ _elements that contain an_
_auth-constraint_ _naming no roles (i.e an excluding_ _auth-constraint_
_). The permissions must be constructed using the qualified (as defined
in link:jacc.html#a288[See Qualified URL Pattern Names]”)
pattern as their name and with actions obtained by combining (as defined
in link:jacc.html#a302[See Combining HTTP Methods]”) the
collections containing the pattern and occurring in a constraint with an
excluding_ _auth-constraint_ _. The constructed permissions must be
added to the excluded policy statements by calling the_
_addToExcludedPolicy_ _method on the_ _PolicyConfiguration_ _object._

 _A WebResourcePermission must be added to
the corresponding role for each distinct combination in the
cross-product of_ _url-pattern_ _and_ _role-name_ _occurring in the_
_security-constraint_ _elements that contain an_ _auth-constraint_
_naming roles. If the “any authenticated user” role-name, “**”, occurs
in an auth-constraint, a WebResourcePermission must also be added to the
“**” role. When an_ _auth-constraint_ _names the reserved_ _role-name_
_, "*", all of the patterns in the containing_ _security-constraint_
_must be combined with all of the roles defined in the web application;
which must not include the role “**” unless the application has defined
an application role named “**”. Each WebResourcePermission object must
be constructed using the qualified pattern as its name and with actions
defined by combining (as defined in link:jacc.html#a302[See
Combining HTTP Methods]”) the collections containing the pattern and
occurring in a constraint that names (or implies via "*") the role to
which the permission is being added. The resulting permissions must be
added to the corresponding roles by calling the_ _addToRole_ _method on
the_ _PolicyConfiguration_ _object._

 _A WebResourcePermission must be added to
the unchecked policy statements for each distinct_ _url-pattern_
_occurring in the_ _security-constraint_ _elements that do not contain
an_ _auth-constraint_ _. Each WebResourcePermission object must be
constructed using the qualified pattern as its name and with actions
defined by combining (as defined in link:jacc.html#a302[See
Combining HTTP Methods]”) the collections containing the pattern and
occurring in a_ _security-constraint_ _without an_ _auth-constraint_ _.
The resulting permissions must be added to the unchecked policy
statements by calling the_ _addToUncheckedPolicy_ _method on the_
_PolicyConfiguration_ _object._

 _A WebUserDataPermission must be added to
the unchecked policy statements for each distinct combination of_
_url-pattern_ _and acceptable connection type resulting from the
processing of the_ _security-constraint_ _elements that do not contain
an excluding_ _auth-constraint_ _. The mapping of security-constraint to
acceptable connection type must be as defined in
link:jacc.html#a330[See Mapping Transport Guarantee to
Connection Type]”. Each WebUserDataPermission object must be constructed
using the qualified pattern as its name and with actions defined by
appendinglink:#a1255[6] a representation of the acceptable
connection type to the HTTP method specification obtained by combining
(as defined in link:jacc.html#a302[See Combining HTTP Methods])
the collections containing the pattern and occurring in a_
_security-constraint_ _that maps to the connection type and that does
not contain an excluding_ _auth-constraint_ _. The resulting permissions
must be added to the unchecked policy statements by calling the_
_addToUncheckedPolicy_ _method on the_ _PolicyConfiguration_ _object._

 _A WebResourcePermission and a
WebUserDataPermission must be obtained for each_ _url-pattern_ _in the
deployment descriptor and the default pattern, "/", that is not combined
by the_ _web-resource-collection_ _elements of the deployment descriptor
with every possible HTTP method valuelink:#a1256[7]. The
permission objects must be constructed using the qualified pattern as
their name and with actions represented by an HTTP method specification
that identifies all of the HTTP methods that do not occur in combination
with the pattern. The form of the HTTP method specification used in the
permission construction depends on the representation of the methods
that occurred in combination with the pattern. If the methods that
occurred are represented by an HttpMethodExceptionList as defined in
link:jacc.html#a318[See HTTP Method Exception List]”), the
permissions must be constructed using an HTTPMethodList naming all of
the HTTP methods named in the exception list. Conversely, if the methods
that occurred are represented by an HTTPMethodList, the permissions must
be constructed using an HTTPMethodExceptionList naming all of the HTTP
methods that occurred with the pattern. If a deny uncovered HTTP methods
semantic is in effect for the web module associated with the
PolicyContext, the resulting permissions must be added to the excluded
policy statements by calling the_ _addToExcludedPolicy_ _method on the_
_PolicyConfiguration_ _object. Otherwise, the permissions must be added
to the unchecked policy statements by calling the_ _addToUncheckedPolic_
_y method on the_ _PolicyConfiguration_ _object._

=== [[a288]]Qualified URL Pattern Names

The URL pattern qualification described in
this section serves to capture the best-matching semantics of the
Servlet constraint model in the qualified names such that the
WebResourcePermission and WebUserDataPermission objects can be tested
using the standard Java SE permission evaluation logic.

The WebResourcePermission and
WebUserDataPermission objects resulting from the translation of a
Servlet deployment descriptor must be constructed with a name produced
by qualifying the URL pattern. The rules for qualifying a URL pattern
are dependent on the rules for determining if one URL pattern matches
another as defined in link:jacc.html#a347[See Servlet
URL-Pattern Matching Rules]”, and are described as follows:

* If the pattern is a path prefix pattern, it
must be qualified by every path-prefix pattern in the deployment
descriptor matched by and different from the pattern being qualified.
The pattern must also be qualified by every exact pattern appearing in
the deployment descriptor that is matched by the pattern being
qualified.
* If the pattern is an extension pattern, it
must be qualified by every path-prefix pattern appearing in the
deployment descriptor and every exact pattern in the deployment
descriptor that is matched by the pattern being qualified.
* If the pattern is the default pattern, "/",
it must be qualified by every other pattern except the default pattern
appearing in the deployment descriptor.
* If the pattern is an exact pattern, its
qualified form must not contain any qualifying patterns.

URL patterns are qualified by appending to
their String representation, a colon separated representation of the
list of patterns that qualify the pattern. Duplicates must not be
included in the list of qualifying patterns, and any qualifying pattern
matched by another qualifying pattern maylink:#a1257[8] be
dropped from the list.

=== QualifyingPatternList ::=

 empty string | colon QualifyingPattern |

===  QualifyingPatternList colon QualifyingPattern

=== QualifiedPattern ::= Pattern QualifyingPatternList

All colon characters occurring within Pattern
and QualifyingPattern elements must be transformed to escaped
encodinglink:#a1258[9] prior to inclusion of the corresponding
element in the QualifiedPattern.

Any pattern, qualified by a pattern that
matches it, is overridden and made irrelevant (in the translation) by
the qualifying pattern. Specifically, all extension patterns and the
default pattern are made irrelevant by the presence of the path prefix
pattern "/*" in a deployment descriptor. Patterns qualified by the "/*"
pattern violate the URLPatternSpec constraints of WebResourcePermission
and WebUserDataPermission names and must be rejected by the
corresponding permission constructors.

=== [[a302]]Combining HTTP Methods

The section defines the rules for combining
HTTP method names occurring in _web-resource-collection_ elements that
apply to a common _url-pattern_ . The rules are commutative and
associative and are as follows:

* Lists of _http-method_ elements combine to
yield a list of _http-method_ elements containing the union (without
duplicates) of the _http-method_ elements that occur in the individual
lists.
* Lists of _http-method-omission_ elements
combine to yield a list containing only the _http-method-omission_
elements that occur in all of the individual lists (i.e., the
intersection).
* A list of _http-method-omission_ elements
combines with a list of _http-method_ elements to yield the list of
_http-method-omission_ elements minus any elements whose method name
occurs in the _http-method_ list.
* An empty list (of _http-method_ and
_http-method-omission_ elements) represents the set of all possible HTTP
methods, including when it results from combination according to the
rules described in this section. An empty list combines with any other
list to yield the empty list.

When these combining rules are applied to a
list of collections, the result is always either an empty list, a
non-empty list of _http-method_ elements, or a non-empty list of
_http-method-omission_ elements. When the result is an empty list, the
corresponding actions value is the null (or the empty string) value.
When the result is a non-empty list of _http-method_ elements the
corresponding actions value is a comma separated list of the HTTP method
names occurring in the _http-method_ elements of the list. When the
result is a non-empty list of _http-method-omission_ elements the
corresponding actions value is an HTTP method exception list (as defined
in link:jacc.html#a318[See HTTP Method Exception
List]link:jacc.html#a318[See HTTP Method Exception List]”)
containing the HTTP method names occurring in the _http-method-omission_
elements of the list. The following table contains the three alternative
combination results and their corresponding actions values.

=== HTTP Method Combination to Actions Correspondence

Combination Result

Actions Value

empty list

null or empty string

list of http-method elements

HttpMethodList (e.g., “GET,POST”)

list of http-method-omission elements

HttpMethodExceptionList (e.g.,”!PUT,DELETE”)

=== [[a318]]HTTP Method Exception List

An HTTP method exception list is used to
represent, by set difference, a non-enumerable subset of the set of all
possible HTTP methods. An exception list represents the subset of the
complete set of HTTP methods formed by subtracting the methods named in
the exception list from the complete set.

An exception list is distinguished by its
first character, which must be the exclamation point (i.e., “!”)
character. A comma separated list of one or more HTTP method names must
follow the exclamation point. The syntax of an HTTP method list is
formally defined as follows:

=== ExtensionMethod ::= any token as defined by IETF RFC 2616

 (i.e., 1*[any CHAR except CTLS or separators
as defined in RFC 2616])



HTTPMethod ::= “GET” | “POST” | “PUT” |
“DELETE” | “HEAD” |

 “OPTIONS” | “TRACE” | ExtensionMethod



HTTPMethodList ::= HTTPMethod |
HTTPMethodList comma HTTPMethod



HTTPMethodExceptionList ::= exclaimationPoint
HTTPMethodList

=== [[a330]]Mapping Transport Guarantee to Connection Type

A _transport-guarantee_ (in a
_user-data-constraint_ ) of NONE, or a _security-constraint_ without a
_user-data-constraint_ , indicates that the associated URL patterns and
HTTP methods may be accessed over any (including an unprotected)
transport. A _transport-guarantee_ of INTEGRAL indicates that acceptable
connections are those deemed by the container to be integrity protected.
A _transport-guarantee_ of CONFIDENTIAL indicates that acceptable
connections are those deemed by the container to be protected for
confidentiality.

=== [[a332]]transport-guarantee to Acceptable Connection Mapping

transport-guarantee in
constraint

connection type

String value

INTEGRAL

":INTEGRAL"

CONFIDENTIAL

":CONFIDENTIAL"

NONE

(including no user-data-constraint)

null

=== [[a343]]Translating Servlet security-role-ref Elements

For each _security-role-ref_ appearing in the
deployment descriptor a corresponding WebRoleRefPermission must be added
to the corresponding role. The name of the WebRoleRefPermission must be
the _servlet-name_ in whose context the _security-role-ref_ is defined.
The actions of the WebRoleRefPermission must be the value of the
_role-name_ (that is the reference), appearing in the
_security-role-ref_ . The deployment tools must call the _addToRole_
method on the _PolicyConfiguration_ object to add the
WebRoleRefPermission object resulting from the translation to the _role_
identified in the _role-link_ appearing in the _security-role-ref_ .

Additional WebRoleRefPermission objects must
be added to the PolicyConfiguration as follows. For each servlet element
in the deployment descriptor a WebRoleRefPermission must be added to
each _security-role_ of the application whose name does not appear as
the _role-name_ in a _security-role-ref_ within the servlet element. If
the “any authenticated user” _role-name_ , “**”, does not appear in a
_security-role-ref_ within the servlet, a WebRoleRefPermission must also
be added for it. The name of each such WebRoleRefPermission must be the
servlet-name of the corresponding servlet element. The actions (that is,
reference) of each such WebRoleRefPermission must be the corresponding
(non-appearing) _role-name_ . The resulting permissions must be added to
the corresponding roles by calling the _addToRole_ method on the
_PolicyConfiguration_ object.

For each security-role defined in the
deployment descriptor and the “any authenticated user” role, “**”, an
additional WebRoleRefPermission mustlink:#a1259[10] be added to
the corresponding role by calling the addToRole method on the
PolicyConfiguration object. The name of all such permissions must be the
empty string, and the actions of each such permission must be the
role-name of the corresponding role.

=== [[a347]]Servlet URL-Pattern Matching Rules

This URL pattern matches another pattern if
they are related, by case sensitive comparison, as follows:

* their pattern values are String equivalent,
or
* this pattern is the path-prefix pattern
"/*", or
* this pattern is a path-prefix pattern (that
is, it starts with "/" and ends with "/*") and the other pattern starts
with the substring of this pattern, minus its last 2 characters, and the
next character of the other pattern, if there is one, is "/", or
* this pattern is an extension pattern (that
is, it starts with "*.") and the other pattern ends with this pattern,
or
* this pattern is the special default
pattern, "/", which matches all other patterns.

=== [[a354]]Example

This example demonstrates the
WebResourcePermission and WebUserDataPermission objects that would
result from the translation of a deployment descriptor that contained
the following _security-constraint_ elements.

=== <!--

The following security-constraint excludes
access to the patterns and method combinations defined by the two
contained web-resource-collections. The first collection excludes access
by all methods except GET and POST, while the second collection excludes
access by all HTTP methods.

-->

<security-constraint>

 <web-resource-collection>


<web-resource-name>sc1.c1</web-resource-name>

 <url-pattern>/a/*</url-pattern>

 <url-pattern>/b/*</url-pattern>

 <url-pattern>/a</url-pattern>

 <url-pattern>/b</url-pattern>


<http-method-omission>GET</http-method-omission>


<http-method-omission>POST</http-method-omission>

===  </web-resource-collection>

 <web-resource-collection>


<web-resource-name>sc1.c2</web-resource-name>

 <url-pattern>*.asp</url-pattern>

 </web-resource-collection>

 <auth-constraint/>

=== </security-constraint>

=== <!--

The following security-constraint restricts
access to the patterns and method combinations defined by the two
contained web-resource-collections to callers in role R1 who connect
using a confidential transport.

-->

<security-constraint>

 <web-resource-collection>


<web-resource-name>sc2.c1</web-resource-name>

 <url-pattern>/a/*</url-pattern>

 <url-pattern>/b/*</url-pattern>

 <http-method>GET</http-method>

===  </web-resource-collection>

 <web-resource-collection>


<web-resource-name>sc2.c2</web-resource-name>

 <url-pattern>/b/*</url-pattern>

 <http-method>POST</http-method>

===  </web-resource-collection>

 <auth-constraint>

 <role-name>R1</role-name>

 </auth-constraint>

 <user-data-constraint>


<transport-guarantee>CONFIDENTIAL</transport-guarantee>

 </user-data-constraint>

=== </security-constraint>

link:jacc.html#a399[See Qualified
URL Pattern Names from Example] contains the qualified URL pattern names
that would result from the translation of the _security-constraint_
elements (including the qualified form of the default pattern). The
second column of link:jacc.html#a399[See Qualified URL Pattern
Names from Example] contains the canonical form of the qualified names.
The values in the second column have been derived from the values in the
first column by removing qualifying patterns matched by other qualifying
patterns.

 

=== [[a399]]Qualified URL Pattern Names from Example

Qualified URL Pattern Name

Canonical Form

/a

/a

/b

/b

/a/*:/a

/a/*:/a

/b/*:/b

/b/*:/b

*.asp:/a/*:/b/*

*.asp:/a/*:/b/*

/:/a:/b:/a/*:/b/*:*.asp

/:/a/*:/b/*:*.asp

link:jacc.html#a416[See Permissions
and PolicyConfiguration Operations from Example] represents the
permissions and PolicyConfiguration operations that would result from
the translation of the security-constraint elements.The names appearing
in the second column of the table are those found in the first column of
link:jacc.html#a399[See Qualified URL Pattern Names from
Example]. As noted previously, any equivalent form of the qualified
names, including their canonical forms, could have been used in the
permission constructions.

 

=== [[a416]]Permissions and PolicyConfiguration Operations from Example

Permission

Type

Name

Actions

Policy

Configuration

Add To

WebResource

/a/*:/a

!GET,POST

excluded

WebUserData

/a/*:/a

!GET,POST

excluded

WebResource

/b/*:/b

!GET,POST

excluded

WebUserData

/b/*:/b

!GET,POST

excluded

WebResource

/a

!GET,POST

excluded

WebUserData

/a

 !GET,POST

excluded

WebResource

/b

 !GET,POST

excluded

WebUserData

/b

 !GET,POST

excluded

WebResource

*.asp:/a/*:/b/*

{empty} nulllink:#a1260[11]

excluded

WebUserData

*.asp:/a/*:/b/*

 null

excluded

WebResource

/a/*:/a

 GET

role(R1)

WebResource

/b/*:/b

 GET,POST

role(R1)

WebUserData

/a/*:/a

 GET:CONFIDENTIAL

unchecked

WebUserData

/b/*:/b

 GET,POST:CONFIDENTIAL

unchecked

WebResource

/a/*:/a

 POST

unchecked

WebUserData

/a/*:/a

 POST

unchecked

WebResource

/a

 GET,POST

unchecked

WebUserData

/a

 GET,POST

unchecked

WebResource

/b

 GET,POST

unchecked

WebUserData

/b

 GET,POST

unchecked

WebResource

/:/a:/b:/a/*:/b/*:*.asp

 null

unchecked

WebUserData

/:/a:/b:/a/*:/b/*:*.asp

 null

unchecked

=== [[a512]]EJB Policy Context Identifiers

To satisfy this specification, an application
server must establish EJB policy context identifiers sufficient to
differentiate all instances of the deployment of an EJB jar on the
application server, or on any other application server with which the
server may share the same policy statement repository.

When an application is composed of multiple
EJB jars, no two jars that share at least one ejb-name value in common
may share the same policy context identifiers.

In cases where EJBs may be packaged in war
files, the application server must assign the EJBs to a policy context
distinct from that to which any web components are assigned.

=== [[a516]]Translating EJB Deployment Descriptors

A reference to a _PolicyConfiguration_ object
must be obtained by calling the _getPolicyConfiguration_ method on the
_PolicyConfigurationFactory_ implementation class of the provider
configured into the container. The policy context identifier used in the
call to _getPolicyConfiguration_ must be a _String_ that satisfies the
requirements described in link:jacc.html#a512[See EJB Policy
Context Identifiers]. The _method-permission, exclude-list,_ and
_security-role-ref_ elements appearing in the deployment descriptor must
be translated into permissions and added to the _PolicyConfiguration_
object to yield an equivalent translation as that defined in the
following sections and such that every EJB method for which the
container performs pre-dispatch access decisions is implied by at least
one permission resulting from the translation. Before the translation is
performed, all policy statements must have been
removedlink:#a1261[12] from the policy context associated with
the returned _PolicyConfiguration._

=== [[a518]]Translating EJB method-permission Elements

For each method element of each
method-permission element, an EJBMethodPermission object translated from
the method element must be added to the policy statements of the
PolicyConfiguration object. The name of each such EJBMethodPermission
object must be the ejb-name from the corresponding method element, and
the actions must be established by translating the _method_ element into
a method specification according to the methodSpec syntax defined in the
documentation of the EJBMethodPermission class. The actions translation
must preserve the degree of specificity with respect to method-name,
method-intf, and method-params inherent in the method element.

If the _method-permission_ element contains
the _unchecked_ element _,_ then the deployment tools must call the
_addToUncheckedPolicy_ method to add the permissions resulting from the
translation to the _PolicyConfiguration_ object. Alternatively, if the
_method-permission_ element contains one or more _role-name_ elements,
then the deployment tools must call the _addToRole_ method to add the
permissions resulting from the translation to the corresponding roles of
the _PolicyConfiguration_ object. These addToRole calls must be made for
any role-name used in the method-permision which may include the
role-name “**”; which, by default, is mapped to any authenticated user.

=== [[a521]]Translating the EJB exclude-list

An EJBMethodPermission object must be created
for each _method_ element occurring in the _exclude-list_ element of the
deployment descriptor. The name and actions of each EJBMethodPermission
must be established as described in link:jacc.html#a518[See
Translating EJB method-permission Elements].”

The deployment tools must use the
_addToExcludedPolicy_ method to add the EJBMethodPermission objects
resulting from the translation of the _exclude-list_ to the excluded
policy statements of the _PolicyConfiguration_ object.

=== [[a524]]Translating EJB security-role-ref Elements

For each _security-role-ref_ element
appearing in the deployment descriptor, a corresponding
EJBRoleRefPermission must be created. The value of the ejb-name element
within the element containing the security-role-ref element must be used
as the name of the EJBRoleRefPermission. The actions used to construct
the permission must be the value of the _role-name_ (that is the
reference), appearing in the _security-role-ref_ . The deployment tools
must call the _addToRole_ method on the _PolicyConfiguration_ object to
add a policy statement corresponding to the EJBRoleRefPermission to the
role identified in the _role-link_ appearing in the _security-role-ref_
.

Additional EJBRoleRefPermission objects must
be added to the PolicyConfiguration as follows. For each element in the
deployment descriptor for which the EJB descriptor schema
supportslink:#a1262[13] inclusion of security-role-ref elements,
an EJBRoleRefPermission must be added to each _security-role_ of the
application whose name does not appear as the _role-name_ in a
_security-role-ref_ within the element. If the “any authenticated user”
_role-name_ , “**”, does not appear in a _security-role-ref_ within the
element, a EJBRoleRefPermission must also be added for it. The name of
each such EJBRoleRefPermission must be the value of the ejb-name element
within the element in which the security-role-ref elements could
otherwise occur. The actions (that is, reference) of each such
EJBRoleRefPermission must be the corresponding (non-appearing)
_role-name_ . The resulting permissions must be
addedlink:#a1263[14] to the corresponding roles by calling the
_addToRole_ method on the _PolicyConfiguration_ object.

=== [[a527]]Deploying an Application or Module

The application server’s deployment tools
must translate the declarative authorization policy appearing in the
application or module deployment descriptor(s) into policy statements
within the Policy providers used by the containers to which the
components of the application or module are being deployed. In Servlet
3.0 containers, the policy statements resulting from the deployment and
initialization of a web module, must represent the effects of any
programmatic registration and security configuration of servlets that
occurred during the initialization of the module.

When a module is deployed, its policy context
must be linked to all the other policy contexts with which it must share
the same principal-to-role mapping. When an application is deployed,
every policy context of the application must be linked to every other
policy context of the application with which it shares a common Policy
provider. Policy contexts are linkedlink:#a1264[15] by calling
the linkConfiguration method on the PolicyConfiguration objects of the
provider.

After the translation and linking has
occurred (note that they may occur in either order) for a policy
context, the _commit_ method must be called on the corresponding
_PolicyConfiguration_ object to place it in service such that its policy
statements will be assimilated by the corresponding Policy providers.
These three operations, translate, link and commit, must be performed
for all of the policy contexts of the application.

Once the translation, linking, and committing
has occurred, a call must be made to _Policy.refresh_ on the Policy
provider used by each of the containers to which the application or
module is being deployed. The calls to _Policy.refresh_ must occur
before the containers will accept requests for the deployed resources.
If a module corresponding to a policy context may have inter-module,
initialization-time, dependencies that must be satisfied before the
translation of the policy context of the dependent module can be
completedlink:#a1265[16], the _commit_ of the depended upon
modules must occur before the initialization of the dependent module,
and the calls to _Policy.refresh_ described above must additionally
occur after the processing of the depended upon modules and before the
initialization of the dependent module.

The policy context identifiers corresponding
to the deployed application or module must be recorded in the
application server so that they can be used by containers to establish
the policy context as required by link:jacc.html#a707[See
Setting the Policy Context]” of the link:jacc.html#a556[See
Policy Decision and Enforcement Subcontract], and such that the Deployer
may subsequently remove or modify the corresponding policy contexts as a
result of the undeployment or redeployment of the application.

=== [[a533]]Undeploying an Application or Module

To ensure that there is not a period during
undeployment when the removal of policy statements on application
components renders what were protected components unprotected, the
application server must stop dispatching requests for the application’s
components before undeploying an application or module.

To undeploy an application or module, the
deployment tools must indicate at all the Policy providers to which
policy contexts of the application or module have been deployed that the
policy contexts associated with the application or module that have been
configured in the provider are to be removed from service. A deployment
tool indicates that a policy context is to be removed from service
either by calling getPolicyConfiguration with the identifier of the
policy context on the provider’s PolicyConfigurationFactory or by
calling delete on the corresponding PolicyConfiguration object. If the
getPolicyConfiguration method is used, the value _true_ should be passed
as the second argument to cause the corresponding policy statements to
be deleted from the context. After the policy contexts are marked for
removal from service, a call must be made to _Policy.refresh_ on all of
the Policy providers from which at least one module of the application
or module was marked for removal from service.

=== [[a536]]Deploying to an existing Policy Configuration

Containers are not required to deploy to an
existing policy configuration. Containers that chose to provide this
functionality must satisfy the following requirements.

To associate an application or module with an
existing set of linked policy contexts, the identifiers of the existing
policy contexts must be applied by the relevant containers in fulfilling
their obligations as defined in the link:jacc.html#a556[See
Policy Decision and Enforcement Subcontract]. The policy contexts should
be verified for existence, by calling the _inService_ method of the
_PolicyConfigurationFactory_ of the Policy providers of the relevant
containers. The deployment tools must call _Policy.refresh_ on the
Policy provider of each of the relevant containers, and the containers
must not perform pre-dispatch decisions or dispatch requests for the
deployed resources until these calls have completed.

In Servlet 3.0 containers, if any
programmatic registration and security configuration of servlets has
occurred during the initialization of a web module associated with a
pre-exiting policy context, the corresponding PolicyConfiguration object
must be opened, its policy statements must be removed, and the policy
translation of the module must be repeated to include the programmatic
effects. The PolicyConfiguration object must be committed, and an
additional call to _Policy.refresh_ must be made after all such
PolicyConfiguration objects are committed.

=== [[a540]]Redeploying a Module

Containers are not required to implement
redeployment functionality. Containers that chose to provide this
functionality must satisfy the following requirements.

To ensure redeployment does not create a
situation where the removal of policy statements on application
components renders what were protected components unprotected, the
application server must stop dispatching requests for the application’s
components before redeployment begins. The application server must not
resume dispatching requests for the application’s components until after
the calls to Policy.refresh, described in
link:jacc.html#a527[See Deploying an Application or Module]”,
have completed.

To redeploy a module, the deployment tools
must indicate at all of the Policy providers to which the module is to
be redeployed that the policy context associated with the module is to
be removed from service. If the module is to be redeployed to the same
policy context at a provider, all policy statements and linkages must be
removed from the policy context at the provider. After the policy
contexts have been marked for removal from service and emptied of policy
statements and linkages (as necessary), the deployment tools must
proceed as described in link:jacc.html#a527[See Deploying an
Application or Module]”.

=== [[a544]]What the Provider Must Do

The provider must include an implementation
of the _javax.security.jacc.PolicyConfigurationFactory_ class along with
a matched implementation of a class that implements the
_javax.security.jacc.PolicyConfiguration_ interface. In addition to
providing a _PolicyConfiguration_ interface for integration with the
application server’s deployment tools, the provider must also include a
management interface for policy administrators to use to grant the
collections of permissions that comprise roles, to principals. This
interface need not be standardized.

The provider must ensure that all of the
permissions added to a role in a policy context are granted to any
principal mapped to the role by the policy administrator. For the any
“authenticated user role”, “**”, and unless an application specific
mapping has been established for this role, the provider must ensure
that all permissions added to the role are granted to any authenticated
user. The provider must ensure that the same principal-to-role mappings
are applied to all linked policy contexts.

The provider must ensure that excluded policy
statements take precedence over overlapping unchecked policy statements,
and that both excluded and unchecked policy statements take precedence
over overlapping role based policy statements.

This specification does not prescribe the
policy language or the methods used within providers to implement the
policy and role requirements described above.

=== [[a549]]Permission to Configure Policy

The _getPolicyConfigurationFactory_ , and
_inService_ methods of the abstract factory class,
_javax.security.jacc.PolicyConfigurationFactory_ , must throw a
SecurityException when called by an AccessControlContext that has not
been granted the “setPolicy” SecurityPermission.

The _getPolicyConfiguration_ method of all
implementations of the _PolicyConfigurationFactory_ abstract class must
throw a SecurityException when called by an AccessControlContext that
has not been granted the “setPolicy” SecurityPermission.

All of the public methods of all of the
concrete implementations of the _PolicyConfiguration_ interface must
throw a SecurityException when called by an AccessControlContext that
has not been granted the “setPolicy” SecurityPermission.

In cases where a required permission is not
held by a caller, the implementation must return without changing the
state of the policy statement repository.

The containers of an application server must
be granted the “getPolicy” SecurityPermission and the “setPolicy”
SecurityPermission. J2EE 1.3 Containers that choose to support this
contract must be granted the “getPolicy” AuthPermission and the
“setPolicy” AuthPermission.

== CHAPTER 4 - 

[[a556]]Policy Decision and
Enforcement Subcontract

The link:jacc.html#a556[See Policy
Decision and Enforcement Subcontract] defines the interactions between
container policy enforcement points and the providers that implement the
policy decisions required by Java EE containers.

=== [[a558]]Policy Enforcement by Servlet Containers

Servlet containers must employ the methods
defined in the following subsections to enforce the authorization
policies established for web resources.

=== [[a560]]Permission Names for Transport and Pre-Dispatch Decisions

The name of the permission checked in a
transport or pre-dispatch decision must be the unqualified request URI
minus the context path. All colon characters occurring within the name
must be represented using escaped encodinglink:#a1266[17]. For
the special case where this transformation of the request URI yields the
URLPattern "/", the empty string URLPattern, "", must be used as the
permission name.

For the special case where the empty string
must be substituted for the "/" pattern in the permission evaluation,
all target related processing (including servlet mapping, filter
mapping, and form based login processing) must be performed using the
original pattern, "/".

=== [[a563]]Evaluation of Transport Guarantees

The Servlet container must obtain a
WebUserDataPermission object with name obtained from the request URI as
defined in link:jacc.html#a560[See Permission Names for
Transport and Pre-Dispatch Decisions]”. The actions of the obtained
permission must be composed of the HTTP method of the request and a
protection value describing the transport layer protection of the
connection on which the request arrived. The protection value must be as
follows:

* If the request arrived on a connection
deemed by the container to be protected for confidentiality, a
protection value of “:CONFIDENTIAL” must be used.
* If the request arrived on a connection
deemed by the container to be protected for integrity (but not
confidentiality), a protection value of “:INTEGRAL” must be used.
* If the request arrived on a connection
deemed by the container to be unprotected, the actions used in the
permission construction must contain only the HTTP method of the
request.

The Servlet container must use one of the
methods described in link:jacc.html#a727[See Checking
AccessControlContext Independent Grants]” to test if access to the
resource using the method and connection type encapsulated in the
WebUserDataPermission is permitted. If a SecurityException is thrown in
the permission determination, it must be caught, and the result of the
determination must be that access to the resource using the method and
connection type is not permitted. If access is not permitted, the
request must be redirected as defined by the Servlet Specification. If
access is permitted, the request must be subjected to a pre-dispatch
decision.

=== [[a569]]Pre-dispatch Decision

The Servlet container must obtain a
WebResourcePermission object with name obtained from the request URI as
defined in link:jacc.html#a560[See Permission Names for
Transport and Pre-Dispatch Decisions]”. The actions of the obtained
permission must be the HTTP method of the request. The Servlet container
must use one of the methods described in
link:jacc.html#a736[See Checking the Caller for a Permission]”
to test if the WebResourcePermission has been granted to the caller. If
a SecurityException is thrown in the permission determination, it must
be caught, and the result of the determination must be that the
permission is not granted to the caller. The Servlet container may only
dispatch the request to the web resource if the WebResourcePermission is
determined to be granted to the caller. Otherwise the request must be
rejected with the appropriate HTTP error message as defined by the
Servlet Specification.

Before it dispatches a call to a web
resource, the container must associate with the call thread an
AccessControlContext containing the principals of (only) the target
component’s runAs identity (as defined in
link:jacc.html#a703[See Component runAs Identity]).

=== [[a572]]Application Embedded Privilege Test

When a call is made from a web resource to
_isUserInRole(String roleName)_ the implementation of this method must
obtain a WebRoleRefPermission object with name corresponding to the
servlet-name of the calling web resource and with actions equal to the
roleName used in the call. For the special case where the call to
_isUserInRole_ is made from a web resource that is not mapped to a
Servlet (i.e. by a _servlet-mapping_ ), the name of the
WebRoleRefPermission must be the empty string. In either case, the
implementation of the isUserInRole method must then use one of the
methods described in link:jacc.html#a736[See Checking the
Caller for a Permission]” to determine if the WebRoleRefPermission has
been granted to the caller. If a SecurityException is thrown in the
permission determination, it must be caught, and the result of the
determination must be that the permission is not granted to the caller.
If it is determined that the WebRoleRefPermission has been granted to
the caller, isUserInRole must return true. Otherwise the return value
must be false.

=== [[a574]]Provider Support for Servlet Policy Enforcement

In support of the policy enforcement done by
servlet containers, providers must implement the policy decision
functionality defined in the following subsections.

=== [[a576]]Servlet Policy Decision Semantics

A Policy provider must use the combined
policy statements of the default policy context (as defined in
link:jacc.html#a747[See Default Policy Context]”) and of the
policy context identified by calling PolicyContext.getContextID to
determine if they imply the permission being checked. If one or more
excluded policy statements imply the checked permission, the evaluation
may terminate and the checked permission must be determined not to be
granted. Otherwise, if one or more unchecked policy statements imply the
checked permission, the checked permission must be determined to be
granted independent of AccessControlContext. If the status of the
checked permission is not resolved by the excluded and unchecked
evaluations, it must be determined if a permission that implies the
checked permission has been granted to the AccessControlContext being
tested for the permission. The checked permission may only be determined
to be granted if a permission that implies the checked permission has
been granted to the AccessControlContext. Otherwise the permission must
be determined not to be granted. The policy decision semantics are
dependent on permission specific rules for determining if the
permissions in policy statements imply the permission being checked.

The WebResourcePermission,
WebUserDataPermission, and WebRoleRefPermission specific rules used to
determine if the permissions in policy statements imply a checked
permission are defined in the next sections.

=== [[a579]]Matching Qualified URL Pattern Names

Qualified URL Patterns names were described
in a subsection of link:jacc.html#a281[See Translating
security-constraint Elements]”. The WebResourcePermission and
WebUserDataPermission classes use the term URLPatternSpec to describe
the syntax of qualified URL pattern names. The URLPatternSpec syntax is
defined as follows:

=== URLPatternList ::= URLPattern | URLPatternList colon URLPattern

URLPatternSpec ::= URLPattern | URLPattern
colon URLPatternList

=== name ::= URLPatternSpec

Given this syntax, A reference URLPatternSpec
matches an argument URLPatternSpec if all of the following are true.

* The first URLPattern in the argument
URLPatternSpec is matched by the first URLPattern in the reference
URLPatternSpec.
* The first URLPattern in the argument
URLPatternSpec is NOT matched by any URLPattern in the URLPatternList of
the reference URLPatternSpec.
* If the first URLPattern in the argument
URLPatternSpec matches the first URLPattern in the reference
URLPatternSpec, then every URLPattern in the URLPatternList of the
reference URLPatternSpec must be matched by a URLPattern in the
URLPatternList of the argument URLPatternSpec.

The comparisons described above are case
sensitive, and all matching is according to the rules defined in
link:jacc.html#a347[See Servlet URL-Pattern Matching Rules]”.

=== [[a589]]Matching HTTP Method Specifications

The WebResourcePermission and
WebUserDataPermission classes use the term HTTPMethodSpec to describe
the syntax of the HTTP method component of their actions values. The
HTTPMethodSpec syntax is defined as follows:

=== HTTPMethodSpec ::= null | emptyString |

===  HTTPMethodExceptionList | HTTPMethodList

Given this syntax, a reference HTTPMethodSpec
matches an argument HTTPMethodSpec if all of the HTTP methods
represented by the actions of the argument specification are included in
the method subset represented by the actions of the reference
specification.

A null or emptyString HTTPMethodSpec
represents the entire set of HTTP methods, and as such, matches any
argument HTTPMethodSpec. An
HTTPMethodExceptionListlink:#a1267[18] matches any subset that
does not include a method named in the exception list. A reference
HTTPMethodList matches an argument HTTPMethodList if the methods named
in the argument list are all named in the reference list. An
HTTPMethodList never matches an argument HTTPMethodExceptionList.
Neither an HTTPMethodList or an HTTPMethodExceptionList matches a null
or emptyString HTTPMethodSpec.

=== WebResourcePermission [[a595]]Matching Rules

A reference WebResourcePermission implies an
argument permission if all of the following are true.

* The argument permission is an instanceof
WebResourcePermission.
* The name of the argument permission is
matched by the name of the reference permission according to the rules
defined in link:jacc.html#a579[See Matching Qualified URL
Pattern Names].
* The HTTP methods represented by the actions
of the argument permission are a subset of the HTTP methods represented
by the actions of the reference permission as defined in
link:jacc.html#a589[See Matching HTTP Method Specifications]”.

The comparisons described above are case
sensitive.

=== [[a601]]WebRoleRefPermission Matching Rules

 A reference WebRoleRefPermission implies an
argument permission if all of the following are true.

* The argument permission is an instanceof
WebRoleRefPermission.
* The name of the argument permission is
equivalent to the name of the reference permission.
* The actions (i.e role reference) of the
argument permission is equivalent to the actions (i.e role reference) of
the reference permission.

The comparisons described above are case
sensitive.

=== [[a607]]WebUserDataPermission Matching Rules

A reference WebUserDataPermission implies an
argument permission if all of the following are true.

* The argument permission is an instanceof
WebUserDataPermission.
* The name of the argument permission is
matched by the name of the reference permission according to the rules
defined in link:jacc.html#a579[See Matching Qualified URL
Pattern Names].
* The HTTP methods represented by the actions
of the argument permission are a subset of the HTTP methods represented
by the actions of the reference permission as defined in
link:jacc.html#a589[See Matching HTTP Method Specifications]”.
* The transportType in the actions of the
reference permission either corresponds to the value "NONE", or equals
the transportType in the actions of the argument permission.

The comparisons described above are case
sensitive.

=== [[a614]]Policy Enforcement by EJB Containers

EJB containers must employ the methods
defined in the following subsections to enforce the authorization
policies established for EJB resources.

=== [[a616]]EJB Pre-dispatch Decision

The EJB container must obtain an
EJBMethodPermission object with name corresponding to the ejb-name of
the target resource and with actions that completely specify the
about-to-be-called method of the EJB by identifying the method
interface, method name, and method signature as defined for a methodSpec
in the documentation of the EJBMethodPermission class.

The EJB container must use one of the methods
described in link:jacc.html#a736[See Checking the Caller for a
Permission]” to determine if the EJBMethodPermission has been granted to
the caller. If a SecurityException is thrown in the permission
determination, it must be caught, and the result of the determination
must be that the permission is not granted to the caller. The EJB
container may only dispatch the request to the EJB resource, if the
EJBMethodPermission is determined to be granted to the caller. Otherwise
the request must be rejected with the appropriate exception, as defined
by the corresponding EJB specification.

Before it dispatches a call to an EJB, the
container must associate with the call thread an AccessControlContext
containing the principals of only the target EJB’s runAs identity (as
defined in link:jacc.html#a703[See Component runAs Identity]).

=== [[a620]]EJB Application Embedded Privilege Test

When an EJB makes a call to
_isCallerInRole(String roleName)_ the implementation of this method must
obtain an EJBRoleRefPermission object with name corresponding to the
ejb-name of the EJB making the call and with actions equal to the
roleName used in the call. The implementation of the isCallerInRole
method must then use one of the methods described in
link:jacc.html#a736[See Checking the Caller for a Permission]”
to determine if the EJBRoleRefPermission has been granted to the caller.
If a SecurityException is thrown in the permission determination, it
must be caught, and the result of the determination must be that the
permission is not granted to the caller. If it is determined that the
EJBRoleRefPermission has been granted to the caller, then isCallerInRole
must return true. Otherwise the return value must be false.

=== [[a622]]Provider Support for EJB Policy Enforcement

In support of the policy enforcement done by
EJB containers, providers must implement the policy decision
functionality defined in the following subsections.

=== [[a624]]EJB Policy Decision Semantics

A Policy provider must employ the policy
decision semantics described in link:jacc.html#a576[See Servlet
Policy Decision Semantics]” in the Processing of EJB Policy decisions.

The EJBMethodPermission and
EJBRoleRefPermission specific rules used to determine if the permissions
in policy statements imply a checked permission are defined in the
following sections.

=== [[a627]]EJBMethodPermission Matching Rules

A reference EJBMethodPermission implies an
argument permission, if all of the following are true.

* The argument permission is an instanceof
EJBMethodPermission.
* The name of the argument permission is
equivalent to the name of the reference permission.
* The methods to which the argument
permission applies (as defined in its actions) must be a subset of the
methods to which the reference permission applies (as defined in its
actions). This rule is satisfied if all of the following conditions are
met.

The method name of the reference permission
is null, the empty string, or equivalent to the method name of the
argument permission.

The method interface of the reference
permission is null, the empty string, or equivalent to the method
interface of the argument permission.

The method parameter type list of the
reference permission is null, the empty string, or equivalent to the
method parameter type list of the argument permission.

The comparisons described above are case
sensitive.



link:jacc.html#a639[See
EJBMethodPermission methodSpec Matching Examples] demonstrate the
properties of EJBMethodPermission matching by example.



=== EJBMethodPermission [[a639]]methodSpec Matching Examples

type

methodInterface

Spec

methodName

Spec

methodParams

Spec

implies

checked

permission

checked permission

Home

doThis

java.lang.String



reference

permission

empty string

empty string

empty string

yes

reference

permission

Home

empty string

empty string

yes

reference

permission

empty string

doThis

empty string

yes

reference

permission

empty string

empty string

java.lang.String

yes

reference

permission

Remote

doThis

java.lang.String

no

reference

permission

Home

doNotDoThis

java.lang.String

no

reference

permission

Home

doThis

java.lang.byte

no

=== [[a697]]EJBRoleRefPermission Matching Rules

A reference EJBRoleRefPermission implies an
argument permission, if all of the following are true.

* The argument permission is an instanceof
EJBRoleRefPermission.
* The name of the argument permission is
equivalent to the name of the reference permission.
* The actions (i.e role reference) of the
argument permission is equivalent to the actions (i.e role reference) of
the reference permission.

The comparisons described above are case
sensitive.

=== [[a703]]Component runAs Identity

The identity used by Servlet or EJB
components in the operations they perform is configured by the Deployer.
This identity is referred to as the component’s runAs identity. By
default (and unless otherwise specified in the EJB or Servlet
specifications), components are configured such that they are assigned
the identity of their caller (such as it is) as their runAs identity.
Alternatively, a Deployer may choose to assign an environment specific
identity as a component’s runAs identity. In this case, the container
must establish the specified identity as the component’s runAs identity
independent of the identity of the component’s caller.

 When a Deployer configures an environment
specific component identity based on a deployment descriptor
specification that the component run with an identity mapped to a role,
those responsible for defining the principal-to-role mapping must ensure
that the specified identity is mapped to the role.

A container establishes a component’s runAs
identity by associating an AccessControlContext with the component’s
thread of execution. The container must ensure that the
AccessControlContext includes a SubjectDomainCombiner; and the container
must protect the AccessControlContext associated with a running
component such that, by default, the component is not granted
permissions sufficient to modify the AccessControlContext.

=== [[a707]]Setting the Policy Context

A policy context identifier is set on a
thread by calling the setContextID method on the PolicyContext utility
class. The value of a thread’s policy context identifier is null until
the setContextID method is called. Before invoking Policy to evaluate a
transport guarantee or to perform a pre-dispatch decision, and before
dispatching into a Servlet or EJB component, a container must ensure
that the thread’s policy context identifier identifies the policy
context corresponding to the instance of the module or application for
which the operation is being performed.

Containers must be granted the “setPolicy”
SecurityPermission independent of policy context identifier (or in all
policy contexts) as they need this permission to set the policy context
identifier.

=== [[a710]]Policy Context Handlers

This specification requires that containers
register policy context handlers with the PolicyContext utility class
such that Policy providers can invoke these handlers to obtain
additional context to apply in their access decisions. Policy context
handlers are objects that implement the PolicyContextHandler interface.
To satisfy the requirements of this specification, containers are
required to provide and register with the PolicyContext class the policy
context handlers described in the following subsections. All of the
required context handlers mustlink:#a1268[19] return the value
null when activated outside of the scope of a container’s processing of
a component request. In this context, the scope of a container's
processing of a component request begins when the container asks policy
to perform the corresponding pre-dispatch access decision and ends
either when the access decision returns a failed authorization or when
the dispatched request returns from the component to the container.

Policy providers must not call methods on or
modify the objects returned by the context handlers if these actions
will cause the container to fail in its processing of the associated
request.

Containers may delay the registration of
required context handlers until the first call to
PolicyContext.getHandlerKeys, or for a specific handler, until the
required context handler is activated (assuming getHandlerKeys has not
been called). When a required context handler for which registration has
been delayed is invoked, the container may return null, and must
complete the registration of the handler before returning.

A provider that is dependent on a handler,
should force registration of the handler in advance of the provider’s
processing of a component request for which the handler is required.
This can be accomplished by invoking the required handler during
initialization of the provider.

=== [[a715]]Container Subject Policy Context Handler

All EJB and Servlet containers must register
a PolicyContextHandler whose getContext method returns a
javax.security.auth.Subject object when invoked with the key
“javax.security.auth.Subject.container”. When this handler is activated
as the result of a policy decision performed by a container before
dispatch

into a component, this handler must return a
Subject containing the principals

and credentials of the “caller” of the
component. When activated from the scope of a dispatched call, this
handler must return a Subject containing the principals and credentials
corresponding to the identity established by the container prior to the
activation of the handler. The identity established by the container
will either be the component’s runAs identity or the caller’s identity
(e.g. when an EJB component calls _isCallerInRole_ ). In all cases, if
the identity of the corresponding Subject has not been established or
authenticated, this handler must return the value null.

=== [[a719]]SOAPMessage Policy Context Handler

All EJB containers must register a
PolicyContextHandler whose getContext method returns a
javax.xml.soap.SOAPMessage object when invoked with the key
“javax.xml.soap.SOAPMessage”. If the request being processed by the
container arrived as a SOAP request at the ServiceEndpoint method
interface, the container must return the SOAP message object when this
handler is activated. Otherwise, this handler must return the value
null.

=== [[a721]]HttpServletRequest Policy Context Handler

All Servlet containers must register a
PolicyContextHandler whose getContext method returns a
javax.servlet.http.HttpServletRequest object when invoked with the key
“javax.servlet.http.HttpServletRequest”. When this handler is activated,
the container must return the HttpServletRequest object corresponding to
the component request being processed by the container.

=== [[a723]]EnterpriseBean Policy Context Handler

All EJB containers must register a
PolicyContextHandler whose getContext method returns a
javax.ejb.EnterpriseBean object when invoked with the key
“javax.ejb.EnterpriseBean”. When this handler is activated, the
container must return the EnterpriseBean object corresponding to the EJB
component request (as restricted below) being processed by the
container. The EnterpriseBean object must only be returned when this
handler is activated within the scope of a container's processing of a
business method of the EJB Remote, Local, or ServiceEndpoint interfaces
of the EnterpriseBean object. The value null must be returned if the
bean implementation class does not implement the
javax.ejb.EnterpriseBean interface.

=== [[a725]]EJB Arguments Policy Context Handler

All EJB containers must register a
PolicyContextHandler whose getContext method returns an array of objects
(Object[]) containing the arguments of the EJB method invocation (in the
same order as they appear in the method signature) when invoked with the
key “javax.ejb.arguments”. The context handler must return the value
null when called in the context of a SOAP request that arrived at the
ServiceEndpoint method interface. Otherwise, the context handler must
return the array of objects corresponding to the parameters of the EJB
component invocation. If there are no parameters in the method
signature, the context handler must return an empty array of Object
(i.e. Object[0]).

=== [[a727]]Checking AccessControlContext Independent Grants

This section describes the techniques used by
containers to check permissions for which policy is defined in terms of
the operation defined by the permission and independent of properties of
the invocation context represented in the AccessControlContext. The
WebUserDataPermission policy statements resulting from the translation
of Servlet _user-data-constraint_ elements are an example of such
permissions. A container must use one of the following techniques to
check an instance of a permission for which policy is defined
independent of AccessControlContext.

* The container calls
_AccessControlContext.checkPermission_ with the permission being checked
as argument. The call to _checkPermission_ may be made on any
AccessControlContext. If _checkPermission_ throws an
AccessControlException, the permission is not granted. Otherwise the
permission is granted.
* The container calls
_AccessController.checkPermission_ with the permission being checked.
The value of the current thread’s AccessControlContext is irrelevant in
the access determination. If _checkPermission_ throws an
AccessControlException, the checked permission is not granted. Otherwise
the permission is granted.
* The container calls
_SecurityManager.checkPermission_ with the permission being checked. If
_checkPermission_ throws an AccessControlException, the checked
permission is not granted. Otherwise the permission is granted.
* The J2EE 1.4 container calls
_Policy.implies_ with two arguments; the permission being checked and a
ProtectionDomain that need not be constructed with principals. The
checked permission is granted if Policy.implies returns true. Otherwise,
the permission is not granted.
* The J2EE 1.4 container calls
_java.security.Policy.getPermissions_ with a ProtectionDomain that need
not be constructed with principals. The container must call the
_implies_ method on the returned PermissionCollection using the
permission being checked as argument. The checked permission is granted
if the PermissionCollection implies it. Otherwise, the permission is not
granted. This technique is supported but not recommended.
* The J2EE 1.3 container calls
_javax.security.auth.Policy.getPermissions_ to determine the collection
of permissions granted independent of AccessControlContext. The Subject
in the call to _getPermissions_ may be null. The container must call the
_implies_ method on the returned PermissionCollection using the
permission being checked as argument. The checked permission is granted
if the PermissionCollection implies it. Otherwise, the permission is not
granted. This technique is supported but not recommended.

Prior to using any of the techniques
described in this section, the container must have established a policy
context identifier as defined in link:jacc.html#a707[See
Setting the Policy Context]”.

=== [[a736]]Checking the Caller for a Permission

A container must determine if the caller has
been granted a permission by evaluating the permission in the context of
an AccessControlContext, ProtectionDomain, or Subject containing the
principals of (only) the callerlink:#a1268[20]. If the caller’s
identity has been asserted or vouched for by a trusted authority (other
than the caller), the principals of the authority must not be included
in the principals of the caller. A container must use one of the
following techniques to determine if a permission has been granted to
the caller.

* The container calls
_AccessControlContext.checkPermission_ with the permission as argument.
The call to _checkPermission_ must be made on an AccessControlContext
that contains the principals of the caller. If checkPermission throws an
AccessControlException, the permission is not granted to the caller.
Otherwise the permission is granted.
* The container calls
_AccessController.checkPermission_ with the permission as argument. The
AccessControlContext associated with the thread on which the call to
_checkPermission_ is made must contain the principals of the caller. If
_checkPermission_ throws an AccessControlException, the permission is
not granted to the caller. Otherwise the permission is granted.
* The container calls
_SecurityManager.checkPermission_ with the permission as argument. The
AccessControlContext associated with the thread on which the call to
_checkPermission_ is made must contain the principals of the caller. If
checkPermission throws an AccessControlException, the permission is not
granted to the caller. Otherwise the permission is granted.
* The J2EE 1.4 container calls
_Policy.implies_ with two arguments; the permission being checked and a
ProtectionDomain constructed with the principals of the caller. The
boolean result returned by _Policy.implies_ indicates whether or not the
permission has been granted to the caller.
* The J2EE 1.4 container calls
_java.security.Policy.getPermissions_ with an argument ProtectionDomain
that was constructed with the principals of the caller. The container
must call the _implies_ method on the returned PermissionCollection
using the permission being checked as argument. If the
PermissionCollection implies the permission being tested, the permission
has been granted to the caller. Otherwise it has not. This technique is
supported but not recommended.link:#a1270[21]
* The J2EE 1.3 container calls
_javax.security.auth.Policy.getPermissions_ with an argument Subject
containing the principals of the caller.The container must call the
_implies_ method on the returned PermissionCollection using the
permission being checked as argument. If the PermissionCollection
implies the permission being tested, the permission has been granted to
the caller. Otherwise it has not. This technique is supported but not
recommended.

Prior to using any of the techniques
described in this section, the container must have established a policy
context identifier as defined in link:jacc.html#a707[See
Setting the Policy Context]”.

=== [[a745]]Missing Policy Contexts

A Policy provider must return that a tested
permission has not been granted if it acquires a non-null policy context
identifier by calling getContextID on the PolicyContext class and the
_inService_ method of the _PolicyConfigurationFactory_ associated with
the provider would return false if called with the policy context
identifier.

=== [[a747]]Default Policy Context

The default policy context contains the
policy statements that apply to the JRE independent of the policy
contexts defined as the result of the deployment of modules or
applications in containers. The policy context identifier of the default
policy context is the null value. The default policy context is never
linked to another PolicyConfiguration, and as such does not share the
principal-to-role mapping of any other policy context.

A Policy provider must include the policy
statements of the default policy context in every access determination
it performs. A Policy provider that either does not call
PolicyContext.getContexdID, or does so and acquires the identifier of
the default policy context, must use only the policy statements of the
default policy context to perform its access determination.

=== [[a750]]Policy Compatibility Requirements

To be compatible with this contract, every
JRE of a J2EE 1.4 application server must perform all of the policy
decisions defined by this contract by interacting with the
_java.security.Policy_ instance available in the JRE via the
_java.security.Policy.getPolicy_ method. Every JRE of a J2EE 1.3
application server must perform all of the policy decisions defined by
this contract by interacting with the _javax.security.auth.Policy_
instance available in the JRE via the
_javax.security.auth.Policy.getPolicy_ method.

If an application server or JRE employs a
custom SecurityManager, the necessary reliance on Policy object may be
accomplished by ensuring that the custom SecurityManager relies on the
appropriate (as defined above) Policy object for all of the policy
decisions defined by this contract.

=== [[a753]]Optimization of Permission Evaluations

Containers may employ the following
optimizations (based on reuse) when the result obtained by repeating the
evaluation will not differ from the previous result or when the time
since the previous evaluation is less than the container’s threshold for
being effected by policy changes:

* Containers may reuse an authorization
result obtained from a previous equivalent permission evaluation.
* Containers may reuse an authorization
result obtained for an unauthenticated caller (i.e. a caller with no
principals) performed as defined in link:jacc.html#a736[See
Checking the Caller for a Permission]” to grant, independent of caller
identity, any permission implied by the unauthenticated result.

This specification does not prescribe how a
container determines when a repeated evaluation will return the same
result. That said, one way that containers could make this determination
is if they are, and can determine if they will be, notified of policy
changes and if they can establish that their policy provider does not
employ additional context (such as could be acquired by calling a
_PolicyContextHandler_ ) in its policy evaluations.

Common practice for containers to receive
such notification could be for them to register to the
_"java.security.Policy.supportsReuse"_ key a _PolicyContextHandler_ and
for the container to determine if its provider will notify it of policy
changes by making a test call to the provider’s _refresh_ method. Only a
provider that is compatible with the optimizations described above
(including because it does not employ additional context in its policy
evaluations) may deliver notice of policy changes by activating this
handler when its _refresh_ method is called.

== CHAPTER 5 - 

[[a760]]API





image:authz.png[image]

=== javax.security.jacc Class Diagrams

=== [#pgfId-658687]##[#marker-658685]##Package

=== [#pgfId-658693]##[#PackageHead]##[#javax.security.jacc]##javax.security.jacc

=== [#pgfId-658695]##Description

[#pgfId-658697]##This package contains the Java Authorization Contract
for Containers API

[#pgfId-658700]##

[#pgfId-656961]##Class Summary

=== [#pgfId-656967]##Interfaces

[#pgfId-656979]##
_link:jacc.html#UNKNOWN[PolicyConfiguration]_

[#pgfId-656981]##The methods of this interface are used by containers to
create policy statements in a Policy provider.

[#pgfId-656993]##
_link:jacc.html#UNKNOWN[PolicyContextHandler]_

[#pgfId-656995]##This interface defines the methods that must be
implemented by handlers that are to be registered and activated by the
_PolicyContext_ class.

=== [#pgfId-657001]##Classes

[#pgfId-657013]##
_link:jacc.html#UNKNOWN[EJBMethodPermission]_

[#pgfId-657015]##Class for EJB method permissions.

[#pgfId-657027]##
_link:jacc.html#UNKNOWN[EJBRoleRefPermission]_

[#pgfId-657029]##Class for EJB _isCallerInRole (String reference)_
permissions.

[#pgfId-657041]##
_link:jacc.html#UNKNOWN[PolicyConfigurationFactory]_

[#pgfId-657043]##Abstract factory and finder class for obtaining the
instance of the class that implements the PolicyConfigurationFactory of
a provider.

[#pgfId-657055]##
_link:jacc.html#UNKNOWN[PolicyContext]_

[#pgfId-657057]##This utility class is used by containers to communicate
policy context identifiers and other policy relevant context to _Policy_
providers.

[#pgfId-657069]##
_link:jacc.html#UNKNOWN[WebResourcePermission]_

[#pgfId-657071]##Class for Servlet web resource permissions.

[#pgfId-657083]##
_link:jacc.html#UNKNOWN[WebRoleRefPermission]_

[#pgfId-657085]##Class for Servlet _isUserInRole (String reference)_
permissions.

[#pgfId-657097]##
_link:jacc.html#UNKNOWN[WebUserDataPermission]_

[#pgfId-657099]##Class for Servlet Web user data permissions.

=== [#pgfId-657105]##Exceptions

[#pgfId-657117]##
_link:jacc.html#UNKNOWN[PolicyContextException]_

[#pgfId-657119]##This checked exception is thrown by implementations of
the _javax.security.jacc.PolicyConfiguration_ Interface, the
_javax.security.jacc.PolicyConfigurationFactory_ abstract class, the
_javax.security.jacc.PolicyContext_ utility class, and implementations
of the _javax.security.jacc.PolicyContextException_ Interface.

=== [#pgfId-658702]##javax.security.jacc

=== [#pgfId-658710]##[#marker-658704]##[#ClassHead]##[#javax.security.jacc.EJBMethodPermission]##EJBMethodPermission

[#pgfId-658712]## 

[#pgfId-658714]## _java.lang.Object_

[#pgfId-658716]## |

[#pgfId-658718]## +-- _java.security.Permission_

[#pgfId-658720]## |

[#pgfId-658722]## +-- _javax.security.jacc.EJBMethodPermission_

=== [#pgfId-658724]##All Implemented Interfaces:

[#pgfId-658726]## _java.io.Serializable_ , _java.security.Guard_

=== [#pgfId-658728]##Declaration

=== [#pgfId-658730]##public final class _EJBMethodPermission_ extends _java.security.Permission_

=== [#pgfId-658732]##Description

[#pgfId-658734]##Class for EJB method permissions.

[#pgfId-658736]##The name of an EJBMethodPermission contains the value
of the ejb-name element in the application’s deployment descriptor that
identifies the target EJB.

[#pgfId-658738]##The actions of an EJBMethodPermission identifies the
methods of the EJB to which the permission applies.

[#pgfId-658740]##Implementations of this class MAY implement
newPermissionCollection or inherit its implementation from the super
class.

=== [#pgfId-658742]##See Also:

[#pgfId-658744]## _java.security.Permission_

[#pgfId-658747]##

[#pgfId-657126]##Member Summary

=== [#pgfId-657132]##Constructors

=== [#pgfId-657138]##

[#pgfId-657146]##
_link:jacc.html#UNKNOWN[EJBMethodPermission(java.lang.String
name, java.lang.String actions)]_

=== [#pgfId-657152]##

[#pgfId-657160]##
_link:jacc.html#UNKNOWN[EJBMethodPermission(java.lang.String
EJBName, java.lang.String methodInterface, java.lang.reflect.Method
method)]_

=== [#pgfId-657166]##

[#pgfId-657174]##
_link:jacc.html#UNKNOWN[EJBMethodPermission(java.lang.String
EJBName, java.lang.String methodName, java.lang.String methodInterface,
java.lang.String[] methodParams)]_

=== [#pgfId-657180]##Methods

=== [#pgfId-657186]## boolean

[#pgfId-657194]##
_link:jacc.html#UNKNOWN[equals(java.lang.Object
o)]_

=== [#pgfId-657200]## _java.lang.String_

[#pgfId-657208]##
_link:jacc.html#UNKNOWN[getActions]_

=== [#pgfId-657214]## int

[#pgfId-657222]##
_link:jacc.html#UNKNOWN[hashCode()]_

=== [#pgfId-657228]## boolean

[#pgfId-657236]##
_link:jacc.html#UNKNOWN[implies(java.security.Permission
permission)]_

[#pgfId-658750]##

[width="100%",cols="100%",options="header",]
|===
|[#pgfId-657241]##Inherited Member Summary
a|
=== [#pgfId-657245]##Methods inherited from class _Object_

|[#pgfId-657249]## _clone()_ , _finalize()_ , _getClass()_ , _notify()_
, _notifyAll()_ , _wait()_ , _wait(long)_ , _wait(long, int)_

a|
=== [#pgfId-657253]##Methods inherited from class _Permission_

|[#pgfId-657257]## _checkGuard(Object)_ , _getName()_ ,
_newPermissionCollection()_ , _toString()_
|===

=== [#pgfId-658752]##

image:authz-3.png[image]

Constructors

=== [#pgfId-658760]##[#marker-658754]##[#MemberHead]##[#javax.security.jacc.EJBMethodPermission.EJBMethodPermission(java.lang.String, java.lang.String)]##EJBMethodPermission( _java.lang.String_ name, _java.lang.String_ actions)

[#pgfId-658762]##public _EJBMethodPermission_ ( _java.lang.String_ name,
_java.lang.String_ actions)

[#pgfId-658764]##Creates a new EJBMethodPermission with the specified
name and actions.

[#pgfId-658766]##The name contains the value of the ejb-name element
corresponding to an EJB in the application’s deployment descriptor.

[#pgfId-658768]##The actions contains a methodSpec. The syntax of the
actions parameter is defined as follows:

[#pgfId-658770]## methodNameSpec ::= methodName | emptyString

[#pgfId-658772]##

[#pgfId-658774]## methodInterfaceName ::= String

[#pgfId-658776]##

[#pgfId-658778]## methodInterfaceSpec ::= methodInterfaceName |
emptyString

[#pgfId-658780]##

{empty}[#pgfId-658782]## typeName ::= typeName | typeName []

[#pgfId-658784]##

[#pgfId-658786]## methodParams ::= typeName | methodParams comma
typeName

[#pgfId-658788]##

[#pgfId-658790]## methodParamsSpec ::= emptyString | methodParams

[#pgfId-658792]##

[#pgfId-658794]## methodSpec ::= null |

[#pgfId-658796]## methodNameSpec |

[#pgfId-658798]## methodNameSpec comma methodInterfaceName |

[#pgfId-658800]## methodNameSpec comma methodInterfaceSpec comma
methodParamsSpec

[#pgfId-658802]##

[#pgfId-658804]##A MethodInterfaceName is a non-empty String and should
contain a method-intf value as defined for use in EJB deployment
descriptors. An implementation must be flexible such that it supports
additional interface names especially if they are standardized by the
EJB Specification. The EJB Specification currently defines the following
method-intf values:

[#pgfId-658806]## \{ "Home", "LocalHome", "Remote", "Local",
"ServiceEndpoint" }

[#pgfId-658808]##

[#pgfId-658810]##A null or empty string methodSpec indicates that the
permission applies to all methods of the EJB. A methodSpec with a
methodNameSpec of the empty string matches all methods of the EJB that
match the methodInterface and methodParams elements of the methodSpec.

[#pgfId-658812]##A methodSpec with a methodInterfaceSpec of the empty
string matches all methods of the EJB that match the methodNameSpec and
methodParamsSpec elements of the methodSpec.

[#pgfId-658814]##A methodSpec without a methodParamsSpec matches all
methods of the EJB that match the methodNameSpec and methodInterface
elements of the methodSpec.

[#pgfId-658816]##The order of the typeNames in methodParams array must
match the order of occurence of the corresponding parameters in the
method signature of the target method(s). Each typeName in the
methodParams must contain the canonical form of the corresponding
parameter’s typeName as defined by the getActions method. A methodSpec
with an empty methodParamsSpec matches all 0 argument methods of the EJB
that match the methodNameSpec and methodInterfaceSpec elements of the
methodSpec.

=== [#pgfId-658818]##Parameters:

[#pgfId-658820]## _name_ - of the EJB to which the permission pertains.

[#pgfId-658822]## _actions_ - identifies the methods of the EJB to which
the permission pertains.

=== [#pgfId-658830]##[#marker-658824]##[#MemberHead]##[#javax.security.jacc.EJBMethodPermission.EJBMethodPermission(java.lang.String, java.lang.String, java.lang.String, java.lang.String\[\])]##EJBMethodPermission( _java.lang.String_ EJBName, _java.lang.String_ methodName, _java.lang.String_ methodInterface, _java.lang.String_ [] methodParams)

[#pgfId-658832]##public _EJBMethodPermission_ ( _java.lang.String_
EJBName, _java.lang.String_ methodName, _java.lang.String_
methodInterface, _java.lang.String_ [] methodParams)

[#pgfId-658834]##Creates a new EJBMethodPermission with name
corresponding to the EJBName and actions composed from methodName,
methodInterface, and methodParams.

=== [#pgfId-658836]##Parameters:

[#pgfId-658838]## _EJBName_ - The string representation of the name of
the EJB as it appears in the corresponding ejb-name element in the
deployment descriptor.

[#pgfId-658840]## _methodName_ - A string that may be used to indicate
the method of the EJB to which the permission pertains. A value of null
or “” indicates that the permission pertains to all methods that match
the other parameters of the permission specification without
consideration of method name.

[#pgfId-658842]## _methodInterface_ - A string that may be used to
specify the EJB interface to which the permission pertains. A value of
null or “”, indicates that the permission pertains to all methods that
match the other parameters of the permission specification without
consideration of the interface they occur on.

[#pgfId-658844]## _methodParams_ - An array of strings that may be used
to specify (by typeNames) the parameter signature of the target methods.
The order of the typeNames in methodParams array must match the order of
occurence of the corresponding parameters in the method signature of the
target method(s). Each typeName in the methodParams array must contain
the canonical form of the corresponding parameter’s typeName as defined
by the getActions method. An empty methodParams array is used to
represent a method signature with no arguments. A value of null
indicates that the permission pertains to all methods that match the
other parameters of the permission specification without consideration
of method signature.

=== [#pgfId-658852]##[#marker-658846]##[#MemberHead]##[#javax.security.jacc.EJBMethodPermission.EJBMethodPermission(java.lang.String, java.lang.String, java.lang.reflect.Method)]##EJBMethodPermission( _java.lang.String_ EJBName, _java.lang.String_ methodInterface, _java.lang.reflect.Method_ method)

[#pgfId-658854]##public _EJBMethodPermission_ ( _java.lang.String_
EJBName, _java.lang.String_ methodInterface, _java.lang.reflect.Method_
method)

[#pgfId-658856]##Creates a new EJBMethodPermission with name
corresponding to the EJBName and actions composed from methodInterface,
and the Method object.

[#pgfId-658858]##A container uses this constructor prior to checking if
a caller has permission to call the method of an EJB.

=== [#pgfId-658860]##Parameters:

[#pgfId-658862]## _EJBName_ - The string representation of the name of
the EJB as it appears in the corresponding ejb-name element in the
deployment descriptor.

[#pgfId-658864]## _methodInterface_ - A string that may be used to
specify the EJB interface to which the permission pertains. A value of
null or “”, indicates that the permission pertains to all methods that
match the other parameters of the permission specification without
consideration of the interface they occur on.

[#pgfId-658866]## _method_ - an instance of the Java.lang.reflect.Method
class corresponding to the method that the container is trying to
determine whether the caller has permission to access. This value must
not be null.

=== [#pgfId-658868]##

image:authz-3.png[image]

Methods

=== [#pgfId-658876]##[#marker-658870]##[#MemberHead]##[#javax.security.jacc.EJBMethodPermission.equals(java.lang.Object)]##equals( _java.lang.Object_ o)

[#pgfId-658878]##public boolean _equals_ ( _java.lang.Object_ o)

[#pgfId-658880]##Checks two EJBMethodPermission objects for equality.
EJBMethodPermission objects are equivalent if they have case sensitive
equivalent name and actions values.

[#pgfId-658882]##Two Permission objects, P1 and P2, are equivalent if
and only if P1.implies(P2) && P2.implies(P1).

=== [#pgfId-658884]##Overrides:

=== [#pgfId-658886]## _equals_ in class _Permission_

=== [#pgfId-658888]##Parameters:

[#pgfId-658890]## _o_ - the EJBMethodPermission object being tested for
equality with this EJBMethodPermission

=== [#pgfId-658892]##Returns:

[#pgfId-658894]##true if the argument EJBMethodPermission object is
equivalent to this EJBMethodPermission.

=== [#pgfId-658902]##[#marker-658896]##[#MemberHead]##[#javax.security.jacc.EJBMethodPermission.getActions()]##getActions()

[#pgfId-658904]##public _java.lang.String_ _getActions_ ()

[#pgfId-658906]##Returns a String containing a canonical representation
of the actions of this EJBMethodPermission. The Canonical form of the
actions of an EJBMethodPermission is described by the following syntax
description.

[#pgfId-658908]## methodNameSpec ::= methodName | emptyString

[#pgfId-658910]##

[#pgfId-658912]## methodInterfaceName ::= String

[#pgfId-658914]##

[#pgfId-658916]## methodInterfaceSpec ::= methodInterfaceName |
emptyString

[#pgfId-658918]##

{empty}[#pgfId-658920]## typeName ::= typeName | typeName []

[#pgfId-658922]##

[#pgfId-658924]## methodParams ::= typeName | methodParams comma
typeName

[#pgfId-658926]##

[#pgfId-658928]## methodParamsSpec ::= emptyString | methodParams

[#pgfId-658930]##

[#pgfId-658932]## methodSpec ::= null |

[#pgfId-658934]## methodName |

[#pgfId-658936]## methodNameSpec comma methodInterfaceName |

[#pgfId-658938]## methodNameSpec comma methodInterfaceSpec comma
methodParamsSpec

[#pgfId-658940]##

[#pgfId-658942]##The canonical form of each typeName must begin with the
fully qualified Java name of the corresponding parameter’s type. The
canonical form of a typeName for an array parameter is the fully
qualified Java name of the array’s component type followed by as many
instances of the string “[]” as there are dimensions to the array. No
additional characters (e.g. blanks) may occur in the canonical form.

[#pgfId-658944]##A MethodInterfaceName is a non-empty String and should
contain a method-intf value as defined for use in EJB deployment
descriptors. An implementation must be flexible such that it supports
additional interface names especially if they are standardized by the
EJB Specification. The EJB Specification currently defines the following
method-intf values:

[#pgfId-658946]## \{ "Home", "LocalHome", "Remote", "Local",
"ServiceEndpoint" }

[#pgfId-658948]##

=== [#pgfId-658950]##Overrides:

=== [#pgfId-658952]## _getActions_ in class _Permission_

=== [#pgfId-658954]##Returns:

[#pgfId-658956]##a String containing the canonicalized actions of this
EJBMethodPermission.

=== [#pgfId-658964]##[#marker-658958]##[#MemberHead]##[#javax.security.jacc.EJBMethodPermission.hashCode()]##hashCode()

[#pgfId-658966]##public int _hashCode_ ()

[#pgfId-658968]##Returns the hash code value for this
EJBMethodPermission. The properties of the returned hash code must be as
follows:

* [#pgfId-658970]##During the lifetime of a Java application, the
hashCode method must return the same integer value every time it is
called on a EJBMethodPermission object. The value returned by hashCode
for a particular EJBMethodPermission need not remain consistent from one
execution of an application to another.
* [#pgfId-658972]##If two EJBMethodPermission objects are equal
according to the equals method, then calling the hashCode method on each
of the two Permission objects must produce the same integer result
(within an application).

=== [#pgfId-658974]##Overrides:

=== [#pgfId-658976]## _hashCode_ in class _Permission_

=== [#pgfId-658978]##Returns:

[#pgfId-658980]##the integer hash code value for this object.

=== [#pgfId-658988]##[#marker-658982]##[#MemberHead]##[#javax.security.jacc.EJBMethodPermission.implies(java.security.Permission)]##implies( _java.security.Permission_ permission)

[#pgfId-658990]##public boolean _implies_ ( _java.security.Permission_
permission)

[#pgfId-658992]##Determines if the argument Permission is “implied by”
this EJBMethodPermission. For this to be the case,

* [#pgfId-658994]##The argument must be an instanceof
EJBMethodPermission
* [#pgfId-658996]##with name equivalent to that of this
EJBMethodPermission, and
* [#pgfId-658998]##the methods to which the argument permission applies
(as defined in its actions) must be a subset of the methods to which
this EJBMethodPermission applies (as defined in its actions).

[#pgfId-659000]##The argument permission applies to a subset of the
methods to which this permission applies if all of the following
conditions are met.

* [#pgfId-659002]##the method name component of the methodNameSpec of
this permission is null, the empty string, or equivalent to the method
name of the argument permission, and
* [#pgfId-659004]##the method interface component of the methodNameSpec
of this permission is null, the empty string, or equivalent to the
method interface of the argument permission, and
* [#pgfId-659006]##the method parameter list component of the
methodNameSpec of this permission is null, the empty string, or
equivalent to the method parameter list of the argument permission.

[#pgfId-659008]##The name and actions comparisons described above are
case sensitive.

=== [#pgfId-659010]##Overrides:

=== [#pgfId-659012]## _implies_ in class _Permission_

=== [#pgfId-659014]##Parameters:

[#pgfId-659016]## _permission_ - “this” EJBMethodPermission is checked
to see if it implies the argument permission.

=== [#pgfId-659018]##Returns:

[#pgfId-659020]##true if the specified permission is implied by this
object, false if not.

=== [#pgfId-659022]##javax.security.jacc

=== [#pgfId-659030]##[#marker-659024]##[#ClassHead]##[#javax.security.jacc.EJBRoleRefPermission]##EJBRoleRefPermission

[#pgfId-659032]## 

[#pgfId-659034]## _java.lang.Object_

[#pgfId-659036]## |

[#pgfId-659038]## +-- _java.security.Permission_

[#pgfId-659040]## |

[#pgfId-659042]## +-- _javax.security.jacc.EJBRoleRefPermission_

=== [#pgfId-659044]##All Implemented Interfaces:

[#pgfId-659046]## _java.io.Serializable_ , _java.security.Guard_

=== [#pgfId-659048]##Declaration

=== [#pgfId-659050]##public final class _EJBRoleRefPermission_ extends _java.security.Permission_

=== [#pgfId-659052]##Description

[#pgfId-659054]##Class for EJB _isCallerInRole (String reference)_
permissions. An EJBRoleRefPermission is a named permission and has
actions.

[#pgfId-659056]##The name of an EJBRoleRefPermission contains the value
of the ejb-name element in the application’s deployment descriptor that
identifies the EJB in whose context the permission is being evalutated.

[#pgfId-659058]##the actions of an EJBRoleRefPermission identifies the
role reference to which the permission applies. An EJBRoleRefPermission
is checked to determine if the subject is a member of the role
identified by the reference.

[#pgfId-659060]##Implementations of this class MAY implement
newPermissionCollection or inherit its implementation from the super
class.

=== [#pgfId-659062]##See Also:

[#pgfId-659064]## _java.security.Permission_

[#pgfId-659067]##

[#pgfId-657264]##Member Summary

=== [#pgfId-657270]##Constructors

=== [#pgfId-657276]##

[#pgfId-657284]##
_link:jacc.html#UNKNOWN[EJBRoleRefPermission(java.lang.String
name, java.lang.String actions)]_

=== [#pgfId-657290]##Methods

=== [#pgfId-657296]## boolean

[#pgfId-657304]##
_link:jacc.html#UNKNOWN[equals(java.lang.Object
o)]_

=== [#pgfId-657310]## _java.lang.String_

[#pgfId-657318]##
_link:jacc.html#UNKNOWN[getActions()]_

=== [#pgfId-657324]## int

[#pgfId-657332]##
_link:jacc.html#UNKNOWN[hashCode()]_

=== [#pgfId-657338]## boolean

[#pgfId-657346]##
_link:jacc.html#UNKNOWN[implies(java.security.Permission
permission)]_

[#pgfId-659070]##

[width="100%",cols="100%",options="header",]
|===
|[#pgfId-657351]##Inherited Member Summary
a|
=== [#pgfId-657355]##Methods inherited from class _Object_

|[#pgfId-657359]## _clone()_ , _finalize()_ , _getClass()_ , _notify()_
, _notifyAll()_ , _wait()_ , _wait(long)_ , _wait(long, int)_

a|
=== [#pgfId-657363]##Methods inherited from class _Permission_

|[#pgfId-657367]## _checkGuard(Object)_ , _getName()_ ,
_newPermissionCollection()_ , _toString()_
|===

=== [#pgfId-659072]##

image:authz-3.png[image]

Constructors

=== [#pgfId-659080]##[#marker-659074]##[#MemberHead]##[#javax.security.jacc.EJBRoleRefPermission.EJBRoleRefPermission(java.lang.String, java.lang.String)]##EJBRoleRefPermission( _java.lang.String_ name, _java.lang.String_ actions)

[#pgfId-659082]##public _EJBRoleRefPermission_ ( _java.lang.String_
name, _java.lang.String_ actions)

[#pgfId-659084]##Creates a new EJBRoleRefPermission with the specified
name and actions.

=== [#pgfId-659086]##Parameters:

[#pgfId-659088]## _name_ - the ejb-name that identifies the EJB in whose
context the role references are to be evaluated.

[#pgfId-659090]## _actions_ - identifies the role reference to which the
permission pertains. The role reference is scoped to the EJB identified
in the name parameter. The value of the role reference must not be
_null_ or the empty string.

=== [#pgfId-659092]##

image:authz-3.png[image]

Methods

=== [#pgfId-659100]##[#marker-659094]##[#MemberHead]##[#javax.security.jacc.EJBRoleRefPermission.equals(java.lang.Object)]##equals( _java.lang.Object_ o)

[#pgfId-659102]##public boolean _equals_ ( _java.lang.Object_ o)

[#pgfId-659104]##Checks two EJBRoleRefPermission objects for equality.
EJBRoleRefPermission objects are equivalent if they have case equivalent
name and actions values.

[#pgfId-659106]##Two Permission objects, P1 and P2, are equivalent if
and only if P1.implies(P2) && P2.implies(P1).

=== [#pgfId-659108]##Overrides:

=== [#pgfId-659110]## _equals_ in class _Permission_

=== [#pgfId-659112]##Parameters:

[#pgfId-659114]## _o_ - the EJBRoleRefPermission object being tested for
equality with this EJBRoleRefPermission.

=== [#pgfId-659116]##Returns:

[#pgfId-659118]##true if the argument EJBRoleRefPermission object is
equivalent to this EJBRoleRefPermission.

=== [#pgfId-659126]##[#marker-659120]##[#MemberHead]##[#javax.security.jacc.EJBRoleRefPermission.getActions()]##getActions()

[#pgfId-659128]##public _java.lang.String_ _getActions_ ()

[#pgfId-659130]##Returns a canonical String representation of the
actions of this EJBRoleRefPermission.

=== [#pgfId-659132]##Overrides:

=== [#pgfId-659134]## _getActions_ in class _Permission_

=== [#pgfId-659136]##Returns:

[#pgfId-659138]##a String containing the canonicalized actions of this
EJBRoleRefPermission.

=== [#pgfId-659146]##[#marker-659140]##[#MemberHead]##[#javax.security.jacc.EJBRoleRefPermission.hashCode()]##hashCode()

[#pgfId-659148]##public int _hashCode_ ()

[#pgfId-659150]##Returns the hash code value for this
EJBRoleRefPermission. The properties of the returned hash code must be
as follows:

* [#pgfId-659152]##During the lifetime of a Java application, the
hashCode method must return the same integer value, every time it is
called on a EJBRoleRefPermission object. The value returned by hashCode
for a particular EJBRoleRefPermission need not remain consistent from
one execution of an application to another.
* [#pgfId-659154]##If two EJBRoleRefPermission objects are equal
according to the equals method, then calling the hashCode method on each
of the two Permission objects must produce the same integer result
(within an application).

=== [#pgfId-659156]##Overrides:

=== [#pgfId-659158]## _hashCode_ in class _Permission_

=== [#pgfId-659160]##Returns:

[#pgfId-659162]##the integer hash code value for this object.

=== [#pgfId-659170]##[#marker-659164]##[#MemberHead]##[#javax.security.jacc.EJBRoleRefPermission.implies(java.security.Permission)]##implies( _java.security.Permission_ permission)

[#pgfId-659172]##public boolean _implies_ ( _java.security.Permission_
permission)

[#pgfId-659174]##Determines if the argument Permission is “implied by”
this EJBRoleRefPermission. For this to be the case,

[#pgfId-659176]##The argument must be an instanceof EJBRoleRefPermission
with name equivalent to that of this EJBRoleRefPermission, and with the
role reference equivalent to that of this EJBRoleRefPermission applies.

[#pgfId-659178]##The name and actions comparisons described above are
case sensitive.

=== [#pgfId-659180]##Overrides:

=== [#pgfId-659182]## _implies_ in class _Permission_

=== [#pgfId-659184]##Parameters:

[#pgfId-659186]## _permission_ - “this” EJBRoleRefPermission is checked
to see if it implies the argument permission.

=== [#pgfId-659188]##Returns:

[#pgfId-659190]##true if the specified permission is implied by this
object, false if not.

=== [#pgfId-659192]##javax.security.jacc

=== [#pgfId-659200]##[#marker-659194]##[#ClassHead]##[#javax.security.jacc.PolicyConfiguration]##PolicyConfiguration

=== [#pgfId-659202]##Declaration

=== [#pgfId-659204]##public interface _PolicyConfiguration_

=== [#pgfId-659206]##Description

[#pgfId-659208]##The methods of this interface are used by containers to
create policy statements in a Policy provider. An object that implements
the PolicyConfiguration interface provides the policy statement
configuration interface for a corresponding policy context within the
corresponding Policy provider.

[#pgfId-659210]##The life cycle of a policy context is defined by three
states; “open”, “inService”, and “deleted”. A policy context is in one
of these three states.

[#pgfId-659212]##A policy context in the “open” state is in the process
of being configured, and may be operated on by any of the methods of the
PolicyConfiguration interface. A policy context in the “open” state must
not be assimilated at _Policy.refresh_ into the policy statements used
by the Policy provider in performing its access decisions. In order for
the policy statements of a policy context to be assimilated by the
associated provider, the policy context must be in the “inService”
state. A policy context in the “open” state is transitioned to the
“inService” state by calling the commit method.

[#pgfId-659214]##A policy context in the “inService” state is available
for assimilation into the policy statements being used to perform access
decisions by the associated Policy provider. Providers assimilate policy
contexts containing policy statements when the refresh method of the
provider is called. When a provider’s refresh method is called, it must
assimilate only those policy contexts whose state is “inService” and it
must ensure that the policy statements put into service for each policy
context are only those defined in the context at the time of the call to
refresh. A policy context in the “inService” state is not available for
additional configuration and may be returned to the “open” state by
calling the getPolicyConfiguration method of the
PolicyConfigurationFactory.

[#pgfId-659216]##A policy context in the “deleted” state is neither
available for configuration, nor is it available for assimilation into
the Provider. A policy context whose state is “deleted” may be reclaimed
for subsequent processing by calling the getPolicyConfiguration method
of the associated PolicyConfigurationFactory. A “deleted” policy context
is transitioned to the “open” state when it it returned as a result of a
call to getPolicyConfiguration.

[#pgfId-659219]##The following table captures the correspondence between
the policy context life cycle and the methods of the PolicyConfiguration
interface. The rightmost 3 columns of the table correspond to the
PolicyConfiguration state identified at the head of the column. The
values in the cells of these columns indicate the next state resulting
from a call to the method identifed in the leftmost column of the
corresponding row, or that calling the method is unsupported in the
state represented by the column (in which case the state will remain
unchanged). +
 +

[#pgfId-657388]##Method

[#pgfId-657390]##Current State to Next State

[#pgfId-657400]##deleted

[#pgfId-657402]##open

[#pgfId-657404]##inService

[#pgfId-657414]##addToExcludedPolicy

[#pgfId-657416]##Unsupported Operation

[#pgfId-657418]##open

[#pgfId-657420]##Unsupported Operation

[#pgfId-657430]##addToRole

[#pgfId-657432]##Unsupported Operation

[#pgfId-657434]##open

[#pgfId-657436]##Unsupported Operation

[#pgfId-657446]##addToUncheckedPolicy

[#pgfId-657448]##Unsupported Operation

[#pgfId-657450]##open

[#pgfId-657452]##Unsupported Operation

[#pgfId-657462]##commit

[#pgfId-657464]##Unsupported Operation

[#pgfId-657466]##inService

[#pgfId-657468]##inService

[#pgfId-657478]##delete

[#pgfId-657480]##deleted

[#pgfId-657482]##deleted

[#pgfId-657484]##deleted

[#pgfId-657494]##getContextID

[#pgfId-657496]##deleted

[#pgfId-657498]##open

[#pgfId-657500]##inService

[#pgfId-657510]##inService

[#pgfId-657512]##deleted

[#pgfId-657514]##open

[#pgfId-657516]##inService

[#pgfId-657526]##linkConfiguration

[#pgfId-657528]##Unsupported Operation

[#pgfId-657530]##open

[#pgfId-657532]##Unsupported Operation

[#pgfId-657542]##removeExcludedPolicy

[#pgfId-657544]##Unsupported Operation

[#pgfId-657546]##open

[#pgfId-657548]##Unsupported Operation

[#pgfId-657558]##removeRole

[#pgfId-657560]##Unsupported Operation

[#pgfId-657562]##open

[#pgfId-657564]##Unsupported Operation

[#pgfId-657574]##removeUncheckedPolicy

[#pgfId-657576]##Unsupported Operation

[#pgfId-657578]##open

[#pgfId-657580]##Unsupported Operation

[#pgfId-659221]## +


[#pgfId-659223]##For a provider implementation to be compatible with
multi-threaded environments, it may be necessary to synchronize the
refresh method of the provider with the methods of its
PolicyConfiguration interface and with the getPolicyConfiguration and
inService methods of its PolicyConfigurationFactory.

=== [#pgfId-659225]##See Also:

[#pgfId-659239]## _java.security.Permission_ ,
_java.security.PermissionCollection_ ,
_link:jacc.html#UNKNOWN[PolicyContextException],
link:jacc.html#UNKNOWN[PolicyConfigurationFactory]_

[#pgfId-659242]##

[#pgfId-657587]##Member Summary

=== [#pgfId-657593]##Methods

=== [#pgfId-657599]## void

[#pgfId-657607]##
_link:jacc.html#UNKNOWN[addToExcludedPolicy(java.security.Permission
permission)]_

=== [#pgfId-657613]## void

[#pgfId-657621]##
_link:jacc.html#UNKNOWN[addToExcludedPolicy(java.security.PermissionCollection
permissions)]_

=== [#pgfId-657627]## void

[#pgfId-657635]##
_link:jacc.html#UNKNOWN[addToRole(java.lang.String
roleName, java.security.Permission permission)]_

=== [#pgfId-657641]## void

[#pgfId-657649]##
_link:jacc.html#UNKNOWN[addToRole](java.lang.String
roleName, java.security.PermissionCollection permissions)_

=== [#pgfId-657655]## void

[#pgfId-657663]##
_link:jacc.html#UNKNOWN[addToUncheckedPolicy(java.security.Permission
permission)]_

=== [#pgfId-657669]## void

[#pgfId-657677]##
_link:jacc.html#UNKNOWN[addToUncheckedPolicy(java.security.PermissionCollection
permissions)]_

=== [#pgfId-657683]## void

[#pgfId-657691]##
_link:jacc.html#UNKNOWN[commit()]_

=== [#pgfId-657697]## void

[#pgfId-657705]##
_link:jacc.html#UNKNOWN[delete()]_

=== [#pgfId-657711]## _java.lang.String_

[#pgfId-657719]##
_link:jacc.html#UNKNOWN[getContextID()]_

=== [#pgfId-657725]## boolean

[#pgfId-657733]##
_link:jacc.html#UNKNOWN[inService()]_

=== [#pgfId-657739]## void

[#pgfId-657753]##
_link:jacc.html#UNKNOWN[linkConfiguration(]link:jacc.html#javax.security.jacc.PolicyConfiguration[PolicyConfiguration
link)]_

=== [#pgfId-657759]## void

[#pgfId-657767]##
_link:jacc.html#UNKNOWN[removeExcludedPolicy()]_

=== [#pgfId-657773]## void

[#pgfId-657781]##
_link:jacc.html#UNKNOWN[removeRole(java.lang.String
roleName)]_

=== [#pgfId-657787]## void

[#pgfId-657795]##
_link:jacc.html#UNKNOWN[removeUncheckedPolicy()]_

=== [#pgfId-659244]##

image:authz-3.png[image]

Methods

=== [#pgfId-659252]##[#marker-659246]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.addToExcludedPolicy(java.security.PermissionCollection)]##addToExcludedPolicy( _java.security.PermissionCollection_ permissions)

[#pgfId-659254]##public void _addToExcludedPolicy_ (
_java.security.PermissionCollection_ permissions) +
throws PolicyContextException

[#pgfId-659256]##Used to add excluded policy statements to this
PolicyConfiguration.

=== [#pgfId-659258]##Parameters:

[#pgfId-659260]## _permissions_ - the collection of permissions to be
added to the excluded policy statements. The collection may be either a
homogenous or heterogenous collection.

=== [#pgfId-659262]##Throws:

[#pgfId-659264]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659266]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659274]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the addToExcludedPolicy method signature. The exception
thrown by the implementation class will be encapsulated (during
construction) in the thrown PolicyContextException.

=== [#pgfId-659282]##[#marker-659276]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.addToExcludedPolicy(java.security.Permission)]##addToExcludedPolicy( _java.security.Permission_ permission)

[#pgfId-659284]##public void _addToExcludedPolicy_ (
_java.security.Permission_ permission) +
throws PolicyContextException

[#pgfId-659286]##Used to add a single excluded policy statement to this
PolicyConfiguration.

=== [#pgfId-659288]##Parameters:

[#pgfId-659290]## _permission_ - the permission to be added to the
excluded policy statements.

=== [#pgfId-659292]##Throws:

[#pgfId-659294]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659296]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659304]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the addToExcludedPolicy method signature. The exception
thrown by the implementation class will be encapsulated (during
construction) in the thrown PolicyContextException.

=== [#pgfId-659312]##[#marker-659306]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.addToRole(java.lang.String, java.security.PermissionCollection)]##addToRole( _java.lang.String_ roleName, _java.security.PermissionCollection_ permissions)

[#pgfId-659314]##public void _addToRole_ ( _java.lang.String_ roleName,
_java.security.PermissionCollection_ permissions) +
throws PolicyContextException

[#pgfId-659316]##Used to add permissions to a named role in this
PolicyConfiguration. If the named role does not exist in the
PolicyConfiguration, it is created as a result of the call to this
function.

[#pgfId-659318]##It is the job of the Policy provider to ensure that all
the permissions added to a role are granted to principals “mapped to the
role”.

=== [#pgfId-659320]##Parameters:

[#pgfId-659322]## _roleName_ - the name of the Role to which the
permissions are to be added.

[#pgfId-659324]## _permissions_ - the collection of permissions to be
added to the role. The collection may be either a homogenous or
heterogenous collection.

=== [#pgfId-659326]##Throws:

[#pgfId-659328]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659330]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659338]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the addToRole method signature. The exception thrown by
the implementation class will be encapsulated (during construction) in
the thrown PolicyContextException.

=== [#pgfId-659346]##[#marker-659340]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.addToRole(java.lang.String, java.security.Permission)]##addToRole( _java.lang.String_ roleName, _java.security.Permission_ permission)

[#pgfId-659348]##public void _addToRole_ ( _java.lang.String_ roleName,
_java.security.Permission_ permission) +
throws PolicyContextException

[#pgfId-659350]##Used to add a single permission to a named role in this
PolicyConfiguration. If the named role does not exist in the
PolicyConfiguration, it is created as a result of the call to this
function.

[#pgfId-659352]##It is the job of the Policy provider to ensure that all
the permissions added to a role are granted to principals “mapped to the
role”.

=== [#pgfId-659354]##Parameters:

[#pgfId-659356]## _roleName_ - the name of the Role to which the
permission is to be added.

[#pgfId-659358]## _permission_ - the permission to be added to the role.

=== [#pgfId-659360]##Throws:

[#pgfId-659362]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659364]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659372]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the addToRole method signature. The exception thrown by
the implementation class will be encapsulated (during construction) in
the thrown PolicyContextException.

=== [#pgfId-659380]##[#marker-659374]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.addToUncheckedPolicy(java.security.PermissionCollection)]##addToUncheckedPolicy( _java.security.PermissionCollection_ permissions)

[#pgfId-659382]##public void _addToUncheckedPolicy_ (
_java.security.PermissionCollection_ permissions) +
throws PolicyContextException

[#pgfId-659384]##Used to add unchecked policy statements to this
PolicyConfiguration.

=== [#pgfId-659386]##Parameters:

[#pgfId-659388]## _permissions_ - the collection of permissions to be
added as unchecked policy statements. The collection may be either a
homogenous or heterogenous collection.

=== [#pgfId-659390]##Throws:

[#pgfId-659392]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659394]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659402]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the addToUncheckedPolicy method signature. The
exception thrown by the implementation class will be encapsulated
(during construction) in the thrown PolicyContextException.

=== [#pgfId-659410]##[#marker-659404]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.addToUncheckedPolicy(java.security.Permission)]##addToUncheckedPolicy( _java.security.Permission_ permission)

[#pgfId-659412]##public void _addToUncheckedPolicy_ (
_java.security.Permission_ permission) +
throws PolicyContextException

[#pgfId-659414]##Used to add a single unchecked policy statement to this
PolicyConfiguration.

=== [#pgfId-659416]##Parameters:

[#pgfId-659418]## _permission_ - the permission to be added to the
unchecked policy statements.

=== [#pgfId-659420]##Throws:

[#pgfId-659422]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659424]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659432]## PolicyContextException - if the implementation throws
a checked exception that has not been accounted for by the
addToUncheckedPolicy method signature. The exception thrown by the
implementation class will be encapsulated (during construction) in the
thrown PolicyContextException.

=== [#pgfId-659440]##[#marker-659434]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.commit()]##commit()

[#pgfId-659442]##public void _commit_ () +
throws PolicyContextException

[#pgfId-659444]##This method is used to set to “inService” the state of
the policy context whose interface is this PolicyConfiguration Object.
Only those policy contexts whose state is “inService” will be included
in the policy contexts processed by the Policy.refresh method. A policy
context whose state is “inService” may be returned to the “open” state
by calling the getPolicyConfiguration method of the PolicyConfiguration
factory with the policy context identifier of the policy context.

[#pgfId-659446]##When the state of a policy context is “inService”,
calling any method other than commit, delete, getContextID, or inService
on its PolicyConfiguration Object will cause an
UnsupportedOperationException to be thrown.

=== [#pgfId-659448]##Throws:

[#pgfId-659450]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659452]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” when this method is called.

[#pgfId-659460]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the commit method signature. The exception thrown by
the implementation class will be encapsulated (during construction) in
the thrown PolicyContextException.

=== [#pgfId-659468]##[#marker-659462]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.delete()]##delete()

[#pgfId-659470]##public void _delete_ () +
throws PolicyContextException

[#pgfId-659472]##Causes all policy statements to be deleted from this
PolicyConfiguration and sets its internal state such that calling any
method, other than delete, getContextID, or inService on the
PolicyConfiguration will be rejected and cause an
UnsupportedOperationException to be thrown.

[#pgfId-659474]##This operation has no affect on any linked
PolicyConfigurations other than removing any links involving the deleted
PolicyConfiguration.

=== [#pgfId-659476]##Throws:

[#pgfId-659478]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659486]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the delete method signature. The exception thrown by
the implementation class will be encapsulated (during construction) in
the thrown PolicyContextException.

=== [#pgfId-659494]##[#marker-659488]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.getContextID()]##getContextID()

[#pgfId-659496]##public _java.lang.String_ _getContextID_ () +
throws PolicyContextException

[#pgfId-659498]##This method returns this object’s policy context
identifier.

=== [#pgfId-659500]##Returns:

[#pgfId-659502]##this object’s policy context identifier.

=== [#pgfId-659504]##Throws:

[#pgfId-659506]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659514]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the getContextID method signature. The exception thrown
by the implementation class will be encapsulated (during construction)
in the thrown PolicyContextException.

=== [#pgfId-659522]##[#marker-659516]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.inService()]##inService()

[#pgfId-659524]##public boolean _inService_ () +
throws PolicyContextException

[#pgfId-659526]##This method is used to determine if the policy context
whose interface is this PolicyConfiguration Object is in the “inService”
state.

=== [#pgfId-659528]##Returns:

[#pgfId-659530]##true if the state of the associated policy context is
“inService”; false otherwise.

=== [#pgfId-659532]##Throws:

[#pgfId-659534]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659542]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the inService method signature. The exception thrown by
the implementation class will be encapsulated (during construction) in
the thrown PolicyContextException.

=== [#pgfId-659556]##[#marker-659544]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.linkConfiguration(javax.security.jacc.PolicyConfiguration)]##linkConfiguration( _link:jacc.html#UNKNOWN[PolicyConfiguration link)]_

[#pgfId-659564]##public void _linkConfiguration_ (
_link:jacc.html#UNKNOWN[PolicyConfiguration
link) +
throws PolicyContextException]_

[#pgfId-659566]##Creates a relationship between this configuration and
another such that they share the same principal-to-role mappings.
PolicyConfigurations are linked to apply a common principal-to-role
mapping to multiple seperately manageable PolicyConfigurations, as is
required when an application is composed of multiple modules.

[#pgfId-659568]##Note that the policy statements which comprise a role,
or comprise the excluded or unchecked policy collections in a
PolicyConfiguration are unaffected by the configuration being linked to
another.

=== [#pgfId-659570]##Parameters:

[#pgfId-659572]## _link_ - a reference to a different
PolicyConfiguration than this PolicyConfiguration.

[#pgfId-659574]##The relationship formed by this method is symetric,
transitive and idempotent. If the argument PolicyConfiguration does not
have a different Policy context identifier than this PolicyConfiguration
no relationship is formed, and an exception, as described below, is
thrown.

=== [#pgfId-659576]##Throws:

[#pgfId-659578]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659580]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659582]## _java.lang.IllegalArgumentException_ - if called with
an argument PolicyConfiguration whose Policy context is equivalent to
that of this PolicyConfiguration.

[#pgfId-659590]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the linkConfiguration method signature. The exception
thrown by the implementation class will be encapsulated (during
construction) in the thrown PolicyContextException.

=== [#pgfId-659598]##[#marker-659592]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.removeExcludedPolicy()]##removeExcludedPolicy()

[#pgfId-659600]##public void _removeExcludedPolicy_ () +
throws PolicyContextException

[#pgfId-659602]##Used to remove any excluded policy statements from this
PolicyConfiguration. This method has no effect on the links between this
PolicyConfiguration and others.

=== [#pgfId-659604]##Throws:

[#pgfId-659606]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659608]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659616]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the removeExcludedPolicy method signature. The
exception thrown by the implementation class will be encapsulated
(during construction) in the thrown PolicyContextException.

=== [#pgfId-659624]##[#marker-659618]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.removeRole(java.lang.String)]##removeRole( _java.lang.String_ roleName)

[#pgfId-659626]##public void _removeRole_ ( _java.lang.String_
roleName) +
throws PolicyContextException

[#pgfId-659628]##Used to remove a role and all its permissions from this
PolicyConfiguration. This method has no effect on the links between this
PolicyConfiguration and others.

=== [#pgfId-659630]##Parameters:

[#pgfId-659632]## _roleName_ - the name of the role to remove from this
PolicyConfiguration. If the value of the roleName parameter is “*” and
no role with name “*” exists in this PolicyConfiguration, then all roles
must be removed from this PolicyConfiguration.

=== [#pgfId-659634]##Throws:

[#pgfId-659636]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659638]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659646]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the removeRole method signature. The exception thrown
by the implementation class will be encapsulated (during construction)
in the thrown PolicyContextException.

=== [#pgfId-659654]##[#marker-659648]##[#MemberHead]##[#javax.security.jacc.PolicyConfiguration.removeUncheckedPolicy()]##removeUncheckedPolicy()

[#pgfId-659656]##public void _removeUncheckedPolicy_ () +
throws PolicyContextException

[#pgfId-659658]##Used to remove any unchecked policy statements from
this PolicyConfiguration. This method has no effect on the links between
this PolicyConfiguration and others.

=== [#pgfId-659660]##Throws:

[#pgfId-659662]## _java.lang.SecurityException_ - if called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659664]## _java.lang.UnsupportedOperationException_ - if the
state of the policy context whose interface is this PolicyConfiguration
Object is “deleted” or “inService” when this method is called.

[#pgfId-659672]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the removeUncheckedPolicy method signature. The
exception thrown by the implementation class will be encapsulated
(during construction) in the thrown PolicyContextException.

=== [#pgfId-659674]##javax.security.jacc

=== [#pgfId-659682]##[#marker-659676]##[#ClassHead]##[#javax.security.jacc.PolicyConfigurationFactory]##PolicyConfigurationFactory

[#pgfId-659684]## 

[#pgfId-659686]## _java.lang.Object_

[#pgfId-659688]## |

[#pgfId-659690]## +-- _javax.security.jacc.PolicyConfigurationFactory_

=== [#pgfId-659692]##Declaration

=== [#pgfId-659694]##public abstract class _PolicyConfigurationFactory_

=== [#pgfId-659696]##Description

[#pgfId-659698]##Abstract factory and finder class for obtaining the
instance of the class that implements the PolicyConfigurationFactory of
a provider. The factory will be used to instantiate PolicyConfiguration
objects that will be used by the deployment tools of the container to
create and manage policy contexts within the Policy Provider.

[#pgfId-659700]##Implementation classes must have a public no argument
constructor that may be used to create an operational instance of the
factory implementation class.

=== [#pgfId-659702]##See Also:

[#pgfId-659716]## _java.security.Permission_ ,
_link:jacc.html#UNKNOWN[PolicyConfiguration],
link:jacc.html#UNKNOWN[PolicyContextException]_

[#pgfId-659719]##

[#pgfId-657802]##Member Summary

=== [#pgfId-657808]##Constructors

=== [#pgfId-657814]##

[#pgfId-657822]##
_link:jacc.html#UNKNOWN[PolicyConfigurationFactory()]_

=== [#pgfId-657828]##Methods

=== [#pgfId-657840]##abstract _link:jacc.html#UNKNOWN[PolicyConfiguration]_

[#pgfId-657848]##
_link:jacc.html#UNKNOWN[getPolicyConfiguration(java.lang.String
contextID, boolean remove)]_

=== [#pgfId-657860]##static _link:jacc.html#UNKNOWN[PolicyConfigurationFactory]_

[#pgfId-657868]##
_link:jacc.html#UNKNOWN[getPolicyConfigurationFactory()]_

=== [#pgfId-657874]##abstract boolean

[#pgfId-657882]##
_link:jacc.html#UNKNOWN[inService(java.lang.String
contextID)]_

[#pgfId-659722]##

[width="100%",cols="100%",options="header",]
|===
|[#pgfId-657887]##Inherited Member Summary
a|
=== [#pgfId-657891]##Methods inherited from class _Object_

|[#pgfId-657895]## _clone()_ , _equals(Object)_ , _finalize()_ ,
_getClass()_ , _hashCode()_ , _notify()_ , _notifyAll()_ , _toString()_
, _wait()_ , _wait(long)_ , _wait(long, int)_
|===

=== [#pgfId-659724]##

image:authz-3.png[image]

Constructors

=== [#pgfId-659732]##[#marker-659726]##[#MemberHead]##[#javax.security.jacc.PolicyConfigurationFactory.PolicyConfigurationFactory()]##PolicyConfigurationFactory()

[#pgfId-659734]##public _PolicyConfigurationFactory_ ()

=== [#pgfId-659736]##

image:authz-3.png[image]

Methods

=== [#pgfId-659744]##[#marker-659738]##[#MemberHead]##[#javax.security.jacc.PolicyConfigurationFactory.getPolicyConfiguration(java.lang.String, boolean)]##getPolicyConfiguration( _java.lang.String_ contextID, boolean remove)

[#pgfId-659752]##public abstract
_link:jacc.html#UNKNOWN[PolicyConfiguration
(java.lang.String contextID, boolean remove) +
throws PolicyContextException]_

[#pgfId-659754]##This method is used to obtain an instance of the
provider specific class that implements the PolicyConfiguration
interface that corresponds to the identified policy context within the
provider. The methods of the PolicyConfiguration interface are used to
define the policy statements of the identified policy context.

[#pgfId-659756]##If at the time of the call, the identified policy
context does not exist in the provider, then the policy context will be
created in the provider and the Object that implements the context’s
PolicyConfiguration Interface will be returned. If the state of the
identified context is “deleted” or “inService” it will be transitioned
to the “open” state as a result of the call. The states in the lifecycle
of a policy context are defined by the PolicyConfiguration interface.

[#pgfId-659758]##For a given value of policy context identifier, this
method must always return the same instance of PolicyConfiguration and
there must be at most one actual instance of a PolicyConfiguration with
a given policy context identifier (during a process context).

[#pgfId-659760]##To preserve the invariant that there be at most one
PolicyConfiguration object for a given policy context, it may be
necessary for this method to be thread safe.

=== [#pgfId-659762]##Parameters:

[#pgfId-659764]## _contextID_ - A String identifying the policy context
whose PolicyConfiguration interface is to be returned. The value passed
to this parameter must not be null.

[#pgfId-659766]## _remove_ - A boolean value that establishes whether or
not the policy statements and linkages of an existing policy context are
to be removed before its PolicyConfiguration object is returned. If the
value passed to this parameter is true, the policy statements and
linkages of an existing policy context will be removed. If the value is
false, they will not be removed.

=== [#pgfId-659768]##Returns:

[#pgfId-659770]##an Object that implements the PolicyConfiguration
Interface matched to the Policy provider and corresponding to the
identified policy context.

=== [#pgfId-659772]##Throws:

[#pgfId-659774]## _java.lang.SecurityException_ - when called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659782]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the getPolicyConfiguration method signature. The
exception thrown by the implementation class will be encapsulated
(during construction) in the thrown PolicyContextException.

=== [#pgfId-659790]##[#marker-659784]##[#MemberHead]##[#javax.security.jacc.PolicyConfigurationFactory.getPolicyConfigurationFactory()]##getPolicyConfigurationFactory()

[#pgfId-659798]##public static
_link:jacc.html#UNKNOWN[PolicyConfigurationFactory
() +
throws ClassNotFoundException, PolicyContextException]_

[#pgfId-659800]##This static method uses a system property to find and
instantiate (via a public constructor) a provider specific factory
implementation class. The name of the provider specific factory
implementation class is obtained from the value of the system property,

[#pgfId-659802]##
javax.security.jacc.PolicyConfigurationFactory.provider.

[#pgfId-659804]##

=== [#pgfId-659806]##Returns:

[#pgfId-659808]##the singleton instance of the provider specific
PolicyConfigurationFactory implementation class.

=== [#pgfId-659810]##Throws:

[#pgfId-659812]## _java.lang.SecurityException_ - when called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659814]## _java.lang.ClassNotFoundException_ - when the class
named by the system property could not be found including because the
value of the system property has not be set.

[#pgfId-659822]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the getPolicyConfigurationFactory method signature. The
exception thrown by the implementation class will be encapsulated
(during construction) in the thrown PolicyContextException.

=== [#pgfId-659830]##[#marker-659824]##[#MemberHead]##[#javax.security.jacc.PolicyConfigurationFactory.inService(java.lang.String)]##inService( _java.lang.String_ contextID)

[#pgfId-659832]##public abstract boolean _inService_ (
_java.lang.String_ contextID) +
throws PolicyContextException

[#pgfId-659834]##This method determines if the identified policy context
exists with state “inService” in the Policy provider associated with the
factory.

=== [#pgfId-659836]##Parameters:

[#pgfId-659838]## _contextID_ - A string identifying a policy context

=== [#pgfId-659840]##Returns:

[#pgfId-659842]##true if the identified policy context exists within the
provider and its state is “inService”, false otherwise.

=== [#pgfId-659844]##Throws:

[#pgfId-659846]## _java.lang.SecurityException_ - when called by an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission.

[#pgfId-659854]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the inService method signature. The exception thrown by
the implementation class will be encapsulated (during construction) in
the thrown PolicyContextException.

=== [#pgfId-659856]##javax.security.jacc

=== [#pgfId-659864]##[#marker-659858]##[#ClassHead]##[#javax.security.jacc.PolicyContext]##PolicyContext

[#pgfId-659866]## 

[#pgfId-659868]## _java.lang.Object_

[#pgfId-659870]## |

[#pgfId-659872]## +-- _javax.security.jacc.PolicyContext_

=== [#pgfId-659874]##Declaration

=== [#pgfId-659876]##public final class _PolicyContext_

=== [#pgfId-659878]##Description

[#pgfId-659880]##This utility class is used by containers to communicate
policy context identifiers and other policy relevant context to _Policy_
providers. _Policy_ providers use the policy context identifier to
select the subset of policy to apply in access decisions.

[#pgfId-659882]##The value of a policy context identifier is a _String_
and each thread has an independently established policy context
identifier. A container will establish the thread-scoped value of a
policy context identifier by calling the static _setContextID_ method.
The value of a thread-scoped policy context identifier is available (to
_Policy_ ) by calling the static _getContextID_ method.

[#pgfId-659884]##This class is also used by _Policy_ providers to
request additional thread-scoped policy relevant context objects from
the calling container. Containers register container-specific
_PolicyContext_ handlers using the static _registerHandler_ method.
Handler registration is scoped to the class, such that the same handler
registrations are active in all thread contexts. Containers may use the
static method _setHandlerData_ to establish a thread-scoped parameter
that will be passed to handlers when they are activated by _Policy_
providers. The static _getContext_ method is used to activate a handler
and obtain the corresponding context object.

[#pgfId-659886]##The static accessor functions provided by this class
allow per-thread policy context values to be established and
communicated independent of a common reference to a particular
PolicyContext instance.

[#pgfId-659888]##The PolicyContext class may encapsulate static
ThreadLocal instance variables to represent the policy context
identifier and handler data values.

[#pgfId-659890]##The Application server must bundle or install the
PolicyContext class, and the containers of the application server must
prevent the methods of the PolicyContext class from being called from
calling contexts that are not authorized to call these methods. With the
exception of the getContextID and GetHandlerKeys methods, containers
must restrict and afford access to the methods of the PolicyContext
class to calling contexts trusted by the container to perform container
access decisions. The PolicyContext class may satisfy this requirement
(on behalf of its container) by rejecting calls made from an
AccessControlContext that has not been granted the “setPolicy”
SecurityPermission, and by ensuring that Policy providers used to
perform container access decisions are granted the “setPolicy”
permission.

=== [#pgfId-659892]##See Also:

[#pgfId-659900]##
_link:jacc.html#UNKNOWN[PolicyContextHandler]_

[#pgfId-659903]##

[#pgfId-657902]##Member Summary

=== [#pgfId-657908]##Methods

=== [#pgfId-657914]##static _java.lang.Object_

[#pgfId-657922]##
_link:jacc.html#UNKNOWN[getContext(java.lang.String
key)]_

=== [#pgfId-657928]##static _java.lang.String_

[#pgfId-657936]##
_link:jacc.html#UNKNOWN[getContextID()]_

=== [#pgfId-657942]##static _java.util.Set_

[#pgfId-657950]##
_link:jacc.html#UNKNOWN[getHandlerKeys()]_

=== [#pgfId-657956]##static void

[#pgfId-657970]##
_link:jacc.html#UNKNOWN[registerHandler(PolicyContextHandler
handler, boolean replace)]_

=== [#pgfId-657976]##static void

[#pgfId-657984]##
_link:jacc.html#UNKNOWN[setContextID(java.lang.String
contextID)]_

=== [#pgfId-657990]##static void

[#pgfId-657998]##
_link:jacc.html#UNKNOWN[setHandlerData(java.lang.Object
data)]_

[#pgfId-659906]##

[width="100%",cols="100%",options="header",]
|===
|[#pgfId-658003]##Inherited Member Summary
a|
=== [#pgfId-658007]##Methods inherited from class _Object_

|[#pgfId-658011]## _clone()_ , _equals(Object)_ , _finalize()_ ,
_getClass()_ , _hashCode()_ , _notify()_ , _notifyAll()_ , _toString()_
, _wait()_ , _wait(long)_ , _wait(long, int)_
|===

=== [#pgfId-659908]##

image:authz-3.png[image]

Methods

=== [#pgfId-659916]##[#marker-659910]##[#MemberHead]##[#javax.security.jacc.PolicyContext.getContext(java.lang.String)]##getContext( _java.lang.String_ key)

[#pgfId-659918]##public static _java.lang.Object_ _getContext_ (
_java.lang.String_ key) +
throws PolicyContextException

[#pgfId-659920]##This method may be used by a _Policy_ provider to
activate the _PolicyContextHandler_ registered to the context object key
and cause it to return the corresponding policy context object from the
container. When this method activates a handler, it passes to the
handler the context object key and the handler data associated with the
calling thread.

=== [#pgfId-659922]##Parameters:

[#pgfId-659924]## _key_ - a _String_ that identifies the
_PolicyContextHandler_ to activate and the context object to be acquired
from the handler. The value of this parameter must not be null.

=== [#pgfId-659926]##Returns:

[#pgfId-659928]##the container and handler specific object containing
the desired context. A _null_ value is returned if the corresponding
handler has been registered, and the value of the corresponding context
is null.

=== [#pgfId-659930]##Throws:

[#pgfId-659932]## _java.lang.IllegalArgumentException_ - if a
_PolicyContextHandler_ has not been registered for the key or the
registered handler no longer supports the key.

[#pgfId-659934]## _java.lang.SecurityException_ - if the calling
AccessControlContext is not authorized by the container to call this
method.

[#pgfId-659942]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if an operation by this method on the identified PolicyContextHandler
causes it to throw a checked exception that is not accounted for in the
signature of this method.

=== [#pgfId-659950]##[#marker-659944]##[#MemberHead]##[#javax.security.jacc.PolicyContext.getContextID()]##getContextID()

[#pgfId-659952]##public static _java.lang.String_ _getContextID_ ()

[#pgfId-659954]##This static method returns the value of the policy
context identifier associated with the thread on which the accessor is
called.

=== [#pgfId-659956]##Returns:

[#pgfId-659958]##The _String_ (or _null_ ) policy context identifier
established for the thread. This method must return the default policy
context identifier, _null_ , if the policy context identifier of the
thread has not been set via _setContext_ to another value.

=== [#pgfId-659960]##Throws:

[#pgfId-659962]## _java.lang.SecurityException_ - if the calling
AccessControlContext is not authorized by the container to call this
method. Containers may choose to authorize calls to this method by any
AccessControlContext.

=== [#pgfId-659970]##[#marker-659964]##[#MemberHead]##[#javax.security.jacc.PolicyContext.getHandlerKeys()]##getHandlerKeys()

[#pgfId-659972]##public static _java.util.Set_ _getHandlerKeys_ ()

[#pgfId-659974]##This method may be used to obtain the keys that
identify the container specific context handlers registered by the
container.

=== [#pgfId-659976]##Returns:

[#pgfId-659978]##A _Set_ , the elements of which, are the _String_ key
values that identify the handlers that have been registered and
therefore may be activated on the _PolicyContext_ .

=== [#pgfId-659980]##Throws:

[#pgfId-659982]## _java.lang.SecurityException_ - if the calling
AccessControlContext is not authorized by the container to call this
method. Containers may choose to authorize calls to this method by any
AccessControlContext.

=== [#pgfId-659996]##[#marker-659984]##[#MemberHead]##[#javax.security.jacc.PolicyContext.registerHandler(java.lang.String, javax.security.jacc.PolicyContextHandler, boolean)]##registerHandler( _java.lang.String_ key, _link:jacc.html#UNKNOWN[PolicyContextHandler]_ handler, _boolean_ replace)

{empty}[#pgfId-660004]##public static void _registerHandler_ (
_java.lang.String_ key,
_link:jacc.html#UNKNOWN[PolicyContextHandler]_
handler, _boolean_ throws
link:jacc.html#UNKNOWN[PolicyContextException]

[#pgfId-660006]##Authorization protected method used to register a
container specific _PolicyContext_ handler. A handler may be registered
to handle multiple keys, but at any time, at most one handler may be
registered for a key.

=== [#pgfId-660008]##Parameters:

[#pgfId-660010]## _key_ - a (case-sensitive) _String_ that identifies
the context object handled by the handler. The value of this parameter
must not be null.

[#pgfId-660012]## _handler_ - an object that implements the
_PolicyContextHandler_ interface. The value of this parameter must not
be null.

[#pgfId-660014]## _replace_ - this boolean value defines the behavior of
this method if, when it is called, a _PolicyContextHandler_ has already
been registered to handle the same key. In that case, and if the value
of this argument is _true_ , the existing handler is replaced with the
argument handler. If the value of this parameter is false the existing
registration is preserved and an exception is thrown.

=== [#pgfId-660016]##Throws:

[#pgfId-660018]## _java.lang.IllegalArgumentException_ - if the value of
either of the handler or key arguments is null, or the value of the
replace argument is _false_ and a handler with the same key as the
argument handler is already registered.

[#pgfId-660020]## _java.lang.SecurityException_ - if the calling
AccessControlContext is not authorized by the container to call this
method.

[#pgfId-660028]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if an operation by this method on the argument PolicyContextHandler
causes it to throw a checked exception that is not accounted for in the
signature of this method.

=== [#pgfId-660036]##[#marker-660030]##[#MemberHead]##[#javax.security.jacc.PolicyContext.setContextID(java.lang.String)]##setContextID( _java.lang.String_ contextID)

[#pgfId-660038]##public static void _setContextID_ ( _java.lang.String_
contextID)

[#pgfId-660040]##Authorization protected method used to modify the value
of the policy context identifier associated with the thread on which
this method is called.

=== [#pgfId-660042]##Parameters:

[#pgfId-660044]## _contextID_ - a _String_ that represents the value of
the policy context identifier to be assigned to the PolicyContext for
the calling thread. The value _null_ is a legitimate value for this
parameter.

=== [#pgfId-660046]##Throws:

[#pgfId-660048]## _java.lang.SecurityException_ - if the calling
AccessControlContext is not authorized by the container to call this
method.

=== [#pgfId-660056]##[#marker-660050]##[#MemberHead]##[#javax.security.jacc.PolicyContext.setHandlerData(java.lang.Object)]##setHandlerData( _java.lang.Object_ data)

[#pgfId-660058]##public static void _setHandlerData_ (
_java.lang.Object_ data)

[#pgfId-660060]##Authorization protected method that may be used to
associate a thread-scoped handler data object with the PolicyContext.
The handler data object will be made available to handlers, where it can
serve to supply or bind the handler to invocation scoped state within
the container.

=== [#pgfId-660062]##Parameters:

[#pgfId-660064]## _data_ - a container-specific object that will be
associated with the calling thread and passed to any handler activated
by a _Policy_ provider (on the thread). The value _null_ is a legitimate
value for this parameter, and is the value that will be used in the
activation of handlers if the _setHandlerData_ has not been called on
the thread.

=== [#pgfId-660066]##Throws:

[#pgfId-660068]## _java.lang.SecurityException_ - if the calling
AccessControlContext is not authorized by the container to call this
method.

=== [#pgfId-660070]##javax.security.jacc

=== [#pgfId-660078]##[#marker-660072]##[#ClassHead]##[#javax.security.jacc.PolicyContextException]##PolicyContextException

[#pgfId-660080]## 

[#pgfId-660082]## _java.lang.Object_

[#pgfId-660084]## |

[#pgfId-660086]## +-- _java.lang.Throwable_

[#pgfId-660088]## |

[#pgfId-660090]## +-- _java.lang.Exception_

[#pgfId-660092]## |

[#pgfId-660094]## +-- _javax.security.jacc.PolicyContextException_

=== [#pgfId-660096]##All Implemented Interfaces:

[#pgfId-660098]## _java.io.Serializable_

=== [#pgfId-660100]##Declaration

=== [#pgfId-660102]##public class _PolicyContextException_ extends _java.lang.Exception_

=== [#pgfId-660104]##Description

[#pgfId-660106]##This checked exception is thrown by implementations of
the _javax.security.jacc.PolicyConfiguration_ Interface, the
_javax.security.jacc.PolicyConfigurationFactory_ abstract class, the
_javax.security.jacc.PolicyContext_ utility class, and implementations
of the _javax.security.jacc.PolicyContextException_ Interface.

[#pgfId-660108]##This exception is used by javax.security.jacc
implementation classes to rethrow checked exceptions ocurring within an
implementation that are not declared by the interface or class being
implemented.

=== [#pgfId-660110]##See Also:

[#pgfId-660136]## _java.lang.Exception_ ,
_link:jacc.html#UNKNOWN[PolicyConfiguration],
link:jacc.html#UNKNOWN[PolicyConfigurationFactory],
link:jacc.html#UNKNOWN[PolicyContext],
link:jacc.html#UNKNOWN[PolicyContextHandler]_

[#pgfId-660139]##

[#pgfId-658018]##Member Summary

=== [#pgfId-658024]##Constructors

=== [#pgfId-658030]##

[#pgfId-658038]##
_link:jacc.html#UNKNOWN[PolicyContextException()]_

=== [#pgfId-658044]##

[#pgfId-658052]##
_link:jacc.html#UNKNOWN[PolicyContextException(java.lang.String
msg)]_

=== [#pgfId-658058]##

[#pgfId-658066]##
_link:jacc.html#UNKNOWN[PolicyContextException(java.lang.String
msg, java.lang.Throwable cause)]_

=== [#pgfId-658072]##

[#pgfId-658080]##
_link:jacc.html#UNKNOWN[PolicyContextException(java.lang.Throwable
cause)]_

[#pgfId-660142]##

[width="100%",cols="100%",options="header",]
|===
|[#pgfId-658085]##Inherited Member Summary
a|
=== [#pgfId-658089]##Methods inherited from class _Object_

|[#pgfId-658093]## _clone()_ , _equals(Object)_ , _finalize()_ ,
_getClass()_ , _hashCode()_ , _notify()_ , _notifyAll()_ , _wait()_ ,
_wait(long)_ , _wait(long, int)_

a|
=== [#pgfId-658097]##Methods inherited from class _Throwable_

|[#pgfId-658101]## _addSuppressed(Throwable)_ , _fillInStackTrace()_ ,
_getCause()_ , _getLocalizedMessage()_ , _getMessage()_ ,
_getStackTrace()_ , _getSuppressed()_ , _initCause(Throwable)_ ,
_printStackTrace()_ , _printStackTrace(PrintStream)_ ,
_printStackTrace(PrintWriter)_ , _setStackTrace(StackTraceElement[])_ ,
_toString()_
|===

=== [#pgfId-660144]##

image:authz-3.png[image]

Constructors

=== [#pgfId-660152]##[#marker-660146]##[#MemberHead]##[#javax.security.jacc.PolicyContextException.PolicyContextException()]##PolicyContextException()

[#pgfId-660154]##public _PolicyContextException_ ()

[#pgfId-660156]##Constructs a new PolicyContextException with _null_ as
its detail message. describing the cause of the exception.

=== [#pgfId-660164]##[#marker-660158]##[#MemberHead]##[#javax.security.jacc.PolicyContextException.PolicyContextException(java.lang.String)]##PolicyContextException( _java.lang.String_ msg)

[#pgfId-660166]##public _PolicyContextException_ ( _java.lang.String_
msg)

[#pgfId-660168]##Constructs a new PolicyContextException with the
specified detail message

=== [#pgfId-660170]##Parameters:

[#pgfId-660172]## _msg_ - - a _String_ containing a detail message
describing the cause of the exception.

=== [#pgfId-660180]##[#marker-660174]##[#MemberHead]##[#javax.security.jacc.PolicyContextException.PolicyContextException(java.lang.String, java.lang.Throwable)]##PolicyContextException( _java.lang.String_ msg, _java.lang.Throwable_ cause)

[#pgfId-660182]##public _PolicyContextException_ ( _java.lang.String_
msg, _java.lang.Throwable_ cause)

[#pgfId-660184]##Constructs a new PolicyContextException with the
specified detail message and cause. The cause will be encapsulated in
the constructed exception.

=== [#pgfId-660186]##Parameters:

[#pgfId-660188]## _msg_ - - a _String containing a detail message
describing the cause of the exception._

[#pgfId-660190]## _cause_ - - the Throwable that is “causing” this
exception to be constructed. A null value is permitted, and the value
passed through this parameter may subsequently be retrieved by calling
_getCause()_ on the constructed exception.

=== [#pgfId-660198]##[#marker-660192]##[#MemberHead]##[#javax.security.jacc.PolicyContextException.PolicyContextException(java.lang.Throwable)]##PolicyContextException( _java.lang.Throwable_ cause)

[#pgfId-660200]##public _PolicyContextException_ ( _java.lang.Throwable_
cause)

[#pgfId-660202]##Constructs a new PolicyContextException with the
specified cause. The cause will be encapsulated in the constructed
exception.

=== [#pgfId-660204]##Parameters:

[#pgfId-660206]## _cause_ - - the Throwable that is “causing” this
exception to be constructed. A null value is permitted, and the value
passed through this parameter may subsequently be retrieved by calling
_getCause()_ on the constructed exception.

=== [#pgfId-660208]##javax.security.jacc

=== [#pgfId-660216]##[#marker-660210]##[#ClassHead]##[#javax.security.jacc.PolicyContextHandler]##PolicyContextHandler

=== [#pgfId-660218]##Declaration

=== [#pgfId-660220]##public interface _PolicyContextHandler_

=== [#pgfId-660222]##Description

[#pgfId-660224]##This interface defines the methods that must be
implemented by handlers that are to be registered and activated by the
_PolicyContext_ class. The _PolicyContext_ class provides methods for
containers to register and activate container-specific _PolicyContext_
handlers. _Policy_ providers use the _PolicyContext_ class to activate
handlers to obtain (from the container) additional policy relevant
context to apply in their access decisions. All handlers registered and
activated via the _PolicyContext_ class must implement the
_PolicyContextHandler_ interface.

=== [#pgfId-660226]##See Also:

[#pgfId-660240]##
_link:jacc.html#UNKNOWN[PolicyContext],
link:jacc.html#UNKNOWN[PolicyContextException]_

[#pgfId-660243]##

[#pgfId-658108]##Member Summary

=== [#pgfId-658114]##Methods

=== [#pgfId-658120]## _java.lang.Object_

[#pgfId-658128]##
_link:jacc.html#UNKNOWN[getContext(java.lang.String
key, java.lang.Object data)]_

=== [#pgfId-658134]## _java.lang.String_ []

[#pgfId-658142]##
_link:jacc.html#UNKNOWN[getKeys()]_

=== [#pgfId-658148]## boolean

[#pgfId-658156]##
_link:jacc.html#UNKNOWN[supports(java.lang.String
key)]_

=== [#pgfId-660245]##

image:authz-3.png[image]

Methods

=== [#pgfId-660253]##[#marker-660247]##[#MemberHead]##[#javax.security.jacc.PolicyContextHandler.getContext(java.lang.String, java.lang.Object)]##getContext( _java.lang.String_ key, _java.lang.Object_ data)

[#pgfId-660255]##public _java.lang.Object_ _getContext_ (
_java.lang.String_ key, _java.lang.Object_ data) +
throws PolicyContextException

[#pgfId-660257]##This public method is used by the _PolicyContext_ class
to activate the handler and obtain from it the context object identified
by the (case-sensitive) key. In addition to the key, the handler will be
activated with the handler data value associated within the
_PolicyContext_ class with the thread on which the call to this method
is made.

[#pgfId-660259]##Note that the policy context identifier associated with
a thread is available to the handler by calling
PolicyContext.getContextID().

=== [#pgfId-660261]##Parameters:

[#pgfId-660263]## _key_ - a String that identifies the context object to
be returned by the handler. The value of this paramter must not be null.

[#pgfId-660265]## _data_ - the handler data _Object_ associated with the
thread on which the call to this method has been made. Note that the
value passed through this parameter may be _null_ .

=== [#pgfId-660267]##Returns:

[#pgfId-660269]##The container and handler specific _Object_ containing
the desired context. A _null_ value may be returned if the value of the
corresponding context is null.

=== [#pgfId-660271]##Throws:

[#pgfId-660279]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the method signature. The exception thrown by the
implementation class will be encapsulated (during construction) in the
thrown PolicyContextException.

=== [#pgfId-660287]##[#marker-660281]##[#MemberHead]##[#javax.security.jacc.PolicyContextHandler.getKeys()]##getKeys()

[#pgfId-660289]##public _java.lang.String_ [] _getKeys_ () +
throws PolicyContextException

[#pgfId-660291]##This public method returns the keys identifying the
context objects supported by the handler. The value of each key
supported by a handler must be a non-null _String_ value.

=== [#pgfId-660293]##Returns:

[#pgfId-660295]##an array containing _String_ values identifing the
context objects supported by the handler. The array must not contain
duplicate key values. In the unlikely case that the Handler supports no
keys, the handler must return a zero length array. The value null must
never be returned by this method.

=== [#pgfId-660297]##Throws:

[#pgfId-660305]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the method signature. The exception thrown by the
implementation class will be encapsulated (during construction) in the
thrown PolicyContextException.

=== [#pgfId-660313]##[#marker-660307]##[#MemberHead]##[#javax.security.jacc.PolicyContextHandler.supports(java.lang.String)]##supports( _java.lang.String_ key)

[#pgfId-660315]##public boolean _supports_ ( _java.lang.String_ key) +
throws PolicyContextException

[#pgfId-660317]##This public method returns a boolean result indicating
whether or not the handler supports the context object identified by the
(case-sensitive) key value.

=== [#pgfId-660319]##Parameters:

[#pgfId-660321]## _key_ - a _String_ value identifying a context object
that could be supported by the handler. The value of this parameter must
not be null.

=== [#pgfId-660323]##Returns:

[#pgfId-660325]##a boolean indicating whether or not the context object
corresponding to the argument key is handled by the handler.

=== [#pgfId-660327]##Throws:

[#pgfId-660335]##
link:jacc.html#UNKNOWN[PolicyContextException]
- if the implementation throws a checked exception that has not been
accounted for by the method signature. The exception thrown by the
implementation class will be encapsulated (during construction) in the
thrown PolicyContextException.

=== [#pgfId-660337]##javax.security.jacc

=== [#pgfId-660345]##[#marker-660339]##[#ClassHead]##[#javax.security.jacc.WebResourcePermission]##WebResourcePermission

[#pgfId-660347]## 

[#pgfId-660349]## _java.lang.Object_

[#pgfId-660351]## |

[#pgfId-660353]## +-- _java.security.Permission_

[#pgfId-660355]## |

[#pgfId-660357]## +-- _javax.security.jacc.WebResourcePermission_

=== [#pgfId-660359]##All Implemented Interfaces:

[#pgfId-660361]## _java.io.Serializable_ , _java.security.Guard_

=== [#pgfId-660363]##Declaration

=== [#pgfId-660365]##public final class _WebResourcePermission_ extends _java.security.Permission_

=== [#pgfId-660367]##Description

[#pgfId-660369]##Class for Servlet web resource permissions. A
WebResourcePermission is a named permission and has actions.

[#pgfId-660371]##The name of a WebResourcePermission (also referred to
as the target name) identifies the Web resources to which the permission
pertains.

[#pgfId-660373]##Implementations of this class MAY implement
newPermissionCollection or inherit its implementation from the super
class.

=== [#pgfId-660375]##See Also:

[#pgfId-660377]## _java.security.Permission_

[#pgfId-660380]##

[#pgfId-658163]##Member Summary

=== [#pgfId-658169]##Constructors

=== [#pgfId-658175]##

[#pgfId-658183]##
_link:jacc.html#UNKNOWN[WebResourcePermission(javax.servlet.http.HttpServletRequest
request)]_

=== [#pgfId-658189]##

[#pgfId-658197]##
_link:jacc.html#UNKNOWN[WebResourcePermission(java.lang.String
name, java.lang.String actions)]_

=== [#pgfId-658203]##

[#pgfId-658211]##
_link:jacc.html#UNKNOWN[WebResourcePermission(java.lang.String
urlPatternSpec, java.lang.String[] HTTPMethods)]_

=== [#pgfId-658217]##Methods

=== [#pgfId-658223]## boolean

[#pgfId-658231]##
_link:jacc.html#UNKNOWN[equals(java.lang.Object
o)]_

=== [#pgfId-658237]## _java.lang.String_

[#pgfId-658245]##
_link:jacc.html#UNKNOWN[getActions()]_

=== [#pgfId-658251]## int

[#pgfId-658259]##
_link:jacc.html#UNKNOWN[hashCode()]_

=== [#pgfId-658265]## boolean

[#pgfId-658273]##
_link:jacc.html#UNKNOWN[implies(java.security.Permission
permission)]_

[#pgfId-660383]##

[width="100%",cols="100%",options="header",]
|===
|[#pgfId-658278]##Inherited Member Summary
a|
=== [#pgfId-658282]##Methods inherited from class _Object_

|[#pgfId-658286]## _clone()_ , _finalize()_ , _getClass()_ , _notify()_
, _notifyAll()_ , _wait()_ , _wait(long)_ , _wait(long, int)_

a|
=== [#pgfId-658290]##Methods inherited from class _Permission_

|[#pgfId-658294]## _checkGuard(Object)_ , _getName()_ ,
_newPermissionCollection()_ , _toString()_
|===

=== [#pgfId-660385]##

image:authz-3.png[image]

Constructors

=== [#pgfId-660393]##[#marker-660387]##[#MemberHead]##[#javax.security.jacc.WebResourcePermission.WebResourcePermission(java.lang.String, java.lang.String)]##WebResourcePermission( _java.lang.String_ name, _java.lang.String_ actions)

[#pgfId-660395]##public _WebResourcePermission_ ( _java.lang.String_
name, _java.lang.String_ actions)

[#pgfId-660397]##Creates a new WebResourcePermission with the specified
name and actions.

[#pgfId-660399]##The name contains a URLPatternSpec that identifies the
web resources to which the permissions applies. The syntax of a
URLPatternSpec is as follows:

[#pgfId-660401]## URLPatternList ::= URLPattern | URLPatternList colon
URLPattern

[#pgfId-660403]##

[#pgfId-660405]## URLPatternSpec ::= null | URLPattern | URLPattern
colon URLPatternList

[#pgfId-660407]##

[#pgfId-660409]##

[#pgfId-660411]##A null URLPatternSpec is translated to the default
URLPattern, “/”, by the permission constructor. The empty string is an
exact URLPattern, and may occur anywhere in a URLPatternSpec that an
exact URLPattern may occur. The first URLPattern in a URLPatternSpec may
be any of the pattern types, exact, path-prefix, extension, or default
as defined in the _Java Servlet Specification)_ . When a URLPatternSpec
includes a URLPatternList, the patterns of the URLPatternList identify
the resources to which the permission does NOT apply and depend on the
pattern type and value of the first pattern as follows:

* [#pgfId-660413]##No pattern may exist in the URLPatternList that
matches the first pattern.
* [#pgfId-660415]##If the first pattern is a path-prefix pattern, only
exact patterns matched by the first pattern and path-prefix patterns
matched by, but different from, the first pattern may occur in the
URLPatternList.
* [#pgfId-660417]##If the first pattern is an extension pattern, only
exact patterns that are matched by the first pattern and path-prefix
patterns may occur in the URLPatternList.
* [#pgfId-660419]##If the first pattern is the default pattern, “/”, any
pattern except the default pattern may occur in the URLPatternList.
* [#pgfId-660421]##If the first pattern is an exact pattern a
URLPatternList must not be present in the URLPatternSpec.

[#pgfId-660423]##The actions parameter contains a comma seperated list
of HTTP methods. The syntax of the actions parameter is defined as
follows:

[#pgfId-660425]## ExtensionMethod ::= any token as defined by RFC 2616

[#pgfId-660427]## (that is, 1*[any CHAR except CTLs or separators])

[#pgfId-660429]##

[#pgfId-660431]## HTTPMethod ::= "GET" | "POST" | "PUT" | "DELETE" |
"HEAD" |

[#pgfId-660433]## "OPTIONS" | "TRACE" | ExtensionMethod

[#pgfId-660435]##

[#pgfId-660437]## HTTPMethodList ::= HTTPMethod | HTTPMethodList comma
HTTPMethod

[#pgfId-660439]##

[#pgfId-660441]## HTTPMethodExceptionList ::= exclaimationPoint
HTTPMethodList

[#pgfId-660443]##

[#pgfId-660445]## HTTPMethodSpec ::= null | HTTPMethodExceptionList |

[#pgfId-660447]## HTTPMethodList

[#pgfId-660449]##

[#pgfId-660451]##

[#pgfId-660453]##If duplicates occur in the HTTPMethodSpec they must be
eliminated by the permission constructor.

[#pgfId-660455]##A null or empty string HTTPMethodSpec indicates that
the permission applies to all HTTP methods at the resources identified
by the URL pattern.

[#pgfId-660457]##If the HTTPMethodSpec contains an
HTTPMethodExceptionList (i.e., it begins with an exclaimationPoint), the
permission pertains to all methods except those occuring in the
exception list.

=== [#pgfId-660459]##Parameters:

[#pgfId-660461]## _name_ - the URLPatternSpec that identifies the
application specific web resources to which the permission pertains. All
URLPatterns in the URLPatternSpec are relative to the context path of
the deployed web application module, and the same URLPattern must not
occur more than once in a URLPatternSpec. A null URLPatternSpec is
translated to the default URLPattern, “/”, by the permission
constructor. All colons occuring within the URLPattern elements of the
URLPatternSpec must be represented in escaped encoding as defined in RFC
2396.

[#pgfId-660463]## _actions_ - identifies the HTTP methods to which the
permission pertains. If the value passed through this parameter is null
or the empty string, then the permission pertains to all the possible
HTTP methods.

=== [#pgfId-660471]##[#marker-660465]##[#MemberHead]##[#javax.security.jacc.WebResourcePermission.WebResourcePermission(java.lang.String, java.lang.String\[\])]##WebResourcePermission( _java.lang.String_ urlPatternSpec, _java.lang.String_ [] HTTPMethods)

[#pgfId-660473]##public _WebResourcePermission_ ( _java.lang.String_
urlPatternSpec, _java.lang.String_ [] HTTPMethods)

[#pgfId-660475]##Creates a new WebResourcePermission with name
corresponding to the URLPatternSpec, and actions composed from the array
of HTTP methods.

=== [#pgfId-660477]##Parameters:

[#pgfId-660479]## _urlPatternSpec_ - the URLPatternSpec that identifies
the application specific web resources to which the permission pertains.
All URLPatterns in the URLPatternSpec are relative to the context path
of the deployed web application module, and the same URLPattern must not
occur more than once in a URLPatternSpec. A null URLPatternSpec is
translated to the default URLPattern, “/”, by the permission
constructor. All colons occuring within the URLPattern elements of the
URLPatternSpec must be represented in escaped encoding as defined in RFC
2396.

[#pgfId-660481]## _HTTPMethods_ - an array of strings each element of
which contains the value of an HTTP method. If the value passed through
this parameter is null or is an array with no elements, then the
permission pertains to all the possible HTTP methods.

=== [#pgfId-660489]##[#marker-660483]##[#MemberHead]##[#javax.security.jacc.WebResourcePermission.WebResourcePermission(javax.servlet.http.HttpServletRequest)]##WebResourcePermission( _javax.servlet.http.HttpServletRequest_ request)

[#pgfId-660491]##public _WebResourcePermission_ (
_javax.servlet.http.HttpServletRequest_ request)

[#pgfId-660493]##Creates a new WebResourcePermission from the
HttpServletRequest object.

=== [#pgfId-660495]##Parameters:

[#pgfId-660497]## _request_ - the HttpServletRequest object
corresponding to the Servlet operation to which the permission pertains.
The permission name is the substring of the requestURI
(HttpServletRequest.getRequestURI()) that begins after the contextPath
(HttpServletRequest.getContextPath()). When the substring operation
yields the string “/”, the permission is constructed with the empty
string as its name. The permission’s actions field is obtained from
HttpServletRequest.getMethod(). The constructor must transform all colon
characters occuring in the name to escaped encoding as defined in RFC
2396.

=== [#pgfId-660499]##

image:authz-3.png[image]

Methods

=== [#pgfId-660507]##[#marker-660501]##[#MemberHead]##[#javax.security.jacc.WebResourcePermission.equals(java.lang.Object)]##equals( _java.lang.Object_ o)

[#pgfId-660509]##public boolean _equals_ ( _java.lang.Object_ o)

[#pgfId-660511]##Checks two WebResourcePermission objects for equality.
WebResourcePermission objects are equivalent if their URLPatternSpec and
(canonicalized) actions values are equivalent. The URLPatternSpec of a
reference permission is equivalent to that of an argument permission if
their first patterns are equivalent, and the patterns of the
URLPatternList of the reference permission collectively match exactly
the same set of patterns as are matched by the patterns of the
URLPatternList of the argument permission.

[#pgfId-660513]##Two Permission objects, P1 and P2, are equivalent if
and only if P1.implies(P2) && P2.implies(P1).

=== [#pgfId-660515]##Overrides:

=== [#pgfId-660517]## _equals_ in class _Permission_

=== [#pgfId-660519]##Parameters:

[#pgfId-660521]## _o_ - the WebResourcePermission object being tested
for equality with this WebResourcePermission.

=== [#pgfId-660523]##Returns:

[#pgfId-660525]##true if the argument WebResourcePermission object is
equivalent to this WebResourcePermission.

=== [#pgfId-660533]##[#marker-660527]##[#MemberHead]##[#javax.security.jacc.WebResourcePermission.getActions()]##getActions()

[#pgfId-660535]##public _java.lang.String_ _getActions_ ()

[#pgfId-660537]##Returns a canonical String representation of the
actions of this WebResourcePermission. In the canonical form, predefined
methods preceed extension methods, and within each method classification
the corresponding methods occur in ascending lexical order. There may be
no duplicate HTTP methods in the canonical form, and the canonical form
of the set of all HTTP methods is the value null.

=== [#pgfId-660539]##Overrides:

=== [#pgfId-660541]## _getActions_ in class _Permission_

=== [#pgfId-660543]##Returns:

[#pgfId-660545]##a String containing the canonicalized actions of this
WebResourcePermission (or the null value).

=== [#pgfId-660553]##[#marker-660547]##[#MemberHead]##[#javax.security.jacc.WebResourcePermission.hashCode()]##hashCode()

[#pgfId-660555]##public int _hashCode_ ()

[#pgfId-660557]##Returns the hash code value for this
WebResourcePermission. The properties of the returned hash code must be
as follows:

* [#pgfId-660559]##During the lifetime of a Java application, the
hashCode method must return the same integer value, every time it is
called on a WebResourcePermission object. The value returned by hashCode
for a particular WebResourcePermission need not remain consistent from
one execution of an application to another.
* [#pgfId-660561]##If two WebResourcePermission objects are equal
according to the equals method, then calling the hashCode method on each
of the two Permission objects must produce the same integer result
(within an application).

=== [#pgfId-660563]##Overrides:

=== [#pgfId-660565]## _hashCode_ in class _Permission_

=== [#pgfId-660567]##Returns:

[#pgfId-660569]##the integer hash code value for this object.

=== [#pgfId-660577]##[#marker-660571]##[#MemberHead]##[#javax.security.jacc.WebResourcePermission.implies(java.security.Permission)]##implies( _java.security.Permission_ permission)

[#pgfId-660579]##public boolean _implies_ ( _java.security.Permission_
permission)

[#pgfId-660581]##Determines if the argument Permission is “implied by”
this WebResourcePermission. For this to be the case, all of the
following must be true:

* [#pgfId-660583]##The argument is an instanceof WebResourcePermission
* [#pgfId-660585]##The first URLPattern in the name of the argument
permission is matched by the first URLPattern in the name of this
permission.
* [#pgfId-660587]##The first URLPattern in the name of the argument
permission is NOT matched by any URLPattern in the URLPatternList of the
URLPatternSpec of this permission.
* [#pgfId-660589]##If the first URLPattern in the name of the argument
permission matches the first URLPattern in the URLPatternSpec of this
permission, then every URLPattern in the URLPatternList of the
URLPatternSpec of this permission is matched by a URLPattern in the
URLPatternList of the argument permission.
* [#pgfId-660591]##The HTTP methods represented by the actions of the
argument permission are a subset of the HTTP methods represented by the
actions of this permission.

[#pgfId-660593]##URLPattern matching is performed using the _Servlet
matching rules_ where two URL patterns match if they are related as
follows:

* [#pgfId-660595]##their pattern values are String equivalent, or
* [#pgfId-660597]##this pattern is the path-prefix pattern “/*”, or
* [#pgfId-660599]##this pattern is a path-prefix pattern (that is, it
starts with “/” and ends with “/*”) and the argument pattern starts with
the substring of this pattern, minus its last 2 characters, and the next
character of the argument pattern, if there is one, is “/”, or
* [#pgfId-660601]##this pattern is an extension pattern (that is, it
starts with “*.”) and the argument pattern ends with this pattern, or
* [#pgfId-660603]##the reference pattern is the special default pattern,
“/”, which matches all argument patterns.

[#pgfId-660605]##All of the comparisons described above are case
sensitive.

=== [#pgfId-660607]##Overrides:

=== [#pgfId-660609]## _implies_ in class _Permission_

=== [#pgfId-660611]##Parameters:

[#pgfId-660613]## _permission_ - “this” WebResourcePermission is checked
to see if it implies the argument permission.

=== [#pgfId-660615]##Returns:

[#pgfId-660617]##true if the specified permission is implied by this
object, false if not.

=== [#pgfId-660619]##javax.security.jacc

=== [#pgfId-660627]##[#marker-660621]##[#ClassHead]##[#javax.security.jacc.WebRoleRefPermission]##WebRoleRefPermission

[#pgfId-660629]## 

[#pgfId-660631]## _java.lang.Object_

[#pgfId-660633]## |

[#pgfId-660635]## +-- _java.security.Permission_

[#pgfId-660637]## |

[#pgfId-660639]## +-- _javax.security.jacc.WebRoleRefPermission_

=== [#pgfId-660641]##All Implemented Interfaces:

[#pgfId-660643]## _java.io.Serializable_ , _java.security.Guard_

=== [#pgfId-660645]##Declaration

=== [#pgfId-660647]##public final class _WebRoleRefPermission_ extends _java.security.Permission_ implements _java.io.Serializable_

=== [#pgfId-660649]##Description

[#pgfId-660651]##Class for Servlet _isUserInRole (String reference)_
permissions. A WebRoleRefPermission is a named permission and has
actions.

[#pgfId-660653]##The name of an WebRoleRefPermission (also referred to
as the target name) identifies a Web resource by the servlet name (in
the deployment descriptor corresponding to the component from which the
call to _isUserInRole (String reference)_ is being made.

[#pgfId-660655]##The actions of an WebRoleRefPermission identifies the
role reference to which the permission applies. A WebRoleRefPermission
is checked to determine if the subject is a member of the role
identified by the reference.

[#pgfId-660657]##Implementations of this class MAY implement
newPermissionCollection or inherit its implementation from the super
class.

=== [#pgfId-660659]##See Also:

[#pgfId-660661]## _java.security.Permission_

[#pgfId-660664]##

[#pgfId-658301]##Member Summary

=== [#pgfId-658307]##Constructors

=== [#pgfId-658313]##

[#pgfId-658321]##
_link:jacc.html#UNKNOWN[WebRoleRefPermission(java.lang.String
name, java.lang.String actions)]_

=== [#pgfId-658327]##Methods

=== [#pgfId-658333]## boolean

[#pgfId-658341]##
_link:jacc.html#UNKNOWN[equals(java.lang.Object
o)]_

=== [#pgfId-658347]## _java.lang.String_

[#pgfId-658355]##
_link:jacc.html#UNKNOWN[getActions()]_

=== [#pgfId-658361]## int

[#pgfId-658369]##
_link:jacc.html#UNKNOWN[hashCode()]_

=== [#pgfId-658375]## boolean

[#pgfId-658383]##
_link:jacc.html#UNKNOWN[implies(java.security.Permission
permission)]_

[#pgfId-660667]##

[width="100%",cols="100%",options="header",]
|===
|[#pgfId-658388]##Inherited Member Summary
a|
=== [#pgfId-658392]##Methods inherited from class _Object_

|[#pgfId-658396]## _clone()_ , _finalize()_ , _getClass()_ , _notify()_
, _notifyAll()_ , _wait()_ , _wait(long)_ , _wait(long, int)_

a|
=== [#pgfId-658400]##Methods inherited from class _Permission_

|[#pgfId-658404]## _checkGuard(Object)_ , _getName()_ ,
_newPermissionCollection()_ , _toString()_
|===

=== [#pgfId-660669]##

image:authz-3.png[image]

Constructors

=== [#pgfId-660677]##[#marker-660671]##[#MemberHead]##[#javax.security.jacc.WebRoleRefPermission.WebRoleRefPermission(java.lang.String, java.lang.String)]##WebRoleRefPermission( _java.lang.String_ name, _java.lang.String_ actions)

[#pgfId-660679]##public _WebRoleRefPermission_ ( _java.lang.String_
name, _java.lang.String_ actions)

[#pgfId-660681]##Creates a new WebRoleRefPermission with the specified
name and actions.

=== [#pgfId-660683]##Parameters:

[#pgfId-660685]## _name_ - the servlet-name that identifies the
application specific web resource in whose context the role references
are to be evaluated.

[#pgfId-660687]## _actions_ - identifies the role reference to which the
permission pertains. The role reference is scoped to the Web resource
identified in the name parameter. The value of the role reference must
not be _null_ or the empty string.

=== [#pgfId-660689]##

image:authz-3.png[image]

Methods

=== [#pgfId-660697]##[#marker-660691]##[#MemberHead]##[#javax.security.jacc.WebRoleRefPermission.equals(java.lang.Object)]##equals( _java.lang.Object_ o)

[#pgfId-660699]##public boolean _equals_ ( _java.lang.Object_ o)

[#pgfId-660701]##Checks two WebRoleRefPermission objects for equality.
WebRoleRefPermission objects are equivalent if they have case equivalent
name and actions values.

[#pgfId-660703]##Two Permission objects, P1 and P2, are equivalent if
and only if P1.implies(P2) && P2.implies(P1).

[#pgfId-660705]##The name and actions comparisons described above are
case sensitive.

=== [#pgfId-660707]##Overrides:

=== [#pgfId-660709]## _equals_ in class _Permission_

=== [#pgfId-660711]##Parameters:

[#pgfId-660713]## _o_ - the WebRoleRefPermission object being tested for
equality with this WebRoleRefPermission.

=== [#pgfId-660715]##Returns:

[#pgfId-660717]##true if the argument WebRoleRefPermission object is
equivalent to this WebRoleRefPermission.

=== [#pgfId-660725]##[#marker-660719]##[#MemberHead]##[#javax.security.jacc.WebRoleRefPermission.getActions()]##getActions()

[#pgfId-660727]##public _java.lang.String_ _getActions_ ()

[#pgfId-660729]##Returns a canonical String representation of the
actions of this WebRoleRefPermission.

=== [#pgfId-660731]##Overrides:

=== [#pgfId-660733]## _getActions_ in class _Permission_

=== [#pgfId-660735]##Returns:

[#pgfId-660737]##a String containing the canonicalized actions of this
WebRoleRefPermission.

=== [#pgfId-660745]##[#marker-660739]##[#MemberHead]##[#javax.security.jacc.WebRoleRefPermission.hashCode()]##hashCode()

[#pgfId-660747]##public int _hashCode_ ()

[#pgfId-660749]##Returns the hash code value for this
WebRoleRefPermission. The properties of the returned hash code must be
as follows:

* [#pgfId-660751]##During the lifetime of a Java application, the
hashCode method must return the same integer value, every time it is
called on a WebRoleRefPermission object. The value returned by hashCode
for a particular WebRoleRefPermission need not remain consistent from
one execution of an application to another.
* [#pgfId-660753]##If two WebRoleRefPermission objects are equal
according to the equals method, then calling the hashCode method on each
of the two Permission objects must produce the same integer result
(within an application).

=== [#pgfId-660755]##Overrides:

=== [#pgfId-660757]## _hashCode_ in class _Permission_

=== [#pgfId-660759]##Returns:

[#pgfId-660761]##the integer hash code value for this object.

=== [#pgfId-660769]##[#marker-660763]##[#MemberHead]##[#javax.security.jacc.WebRoleRefPermission.implies(java.security.Permission)]##implies( _java.security.Permission_ permission)

[#pgfId-660771]##public boolean _implies_ ( _java.security.Permission_
permission)

[#pgfId-660773]##Determines if the argument Permission is “implied by”
this WebRoleRefPermission. For this to be the case,

* [#pgfId-660775]##The argument must be an instanceof
WebRoleRefPermission
* [#pgfId-660777]##with name equivalent to this WebRoleRefPermission,
and
* [#pgfId-660779]##with role reference equivalent to this
WebRoleRefPermission (as defined in their actions).

[#pgfId-660781]##The comparisons described above are case sensitive.

=== [#pgfId-660783]##Overrides:

=== [#pgfId-660785]## _implies_ in class _Permission_

=== [#pgfId-660787]##Parameters:

[#pgfId-660789]## _permission_ - “this” WebRoleRefPermission is checked
to see if it implies the argument permission.

=== [#pgfId-660791]##Returns:

[#pgfId-660793]##true if the specified permission is implied by this
object, false if not.

=== [#pgfId-660795]##javax.security.jacc

=== [#pgfId-660803]##[#marker-660797]##[#ClassHead]##[#javax.security.jacc.WebUserDataPermission]##WebUserDataPermission

[#pgfId-660805]## 

[#pgfId-660807]## _java.lang.Object_

[#pgfId-660809]## |

[#pgfId-660811]## +-- _java.security.Permission_

[#pgfId-660813]## |

[#pgfId-660815]## +-- _javax.security.jacc.WebUserDataPermission_

=== [#pgfId-660817]##All Implemented Interfaces:

[#pgfId-660819]## _java.io.Serializable_ , _java.security.Guard_

=== [#pgfId-660821]##Declaration

=== [#pgfId-660823]##public final class _WebUserDataPermission_ extends _java.security.Permission_

=== [#pgfId-660825]##Description

[#pgfId-660827]##Class for Servlet Web user data permissions. A
WebUserDataPermission is a named permission and has actions.

[#pgfId-660829]##The name of a WebUserDataPermission (also referred to
as the target name) identifies a Web resource by its context path
relative URL pattern.

=== [#pgfId-660831]##See Also:

[#pgfId-660833]## _java.security.Permission_

[#pgfId-660836]##

[#pgfId-658411]##Member Summary

=== [#pgfId-658417]##Constructors

=== [#pgfId-658423]##

[#pgfId-658431]##
_link:jacc.html#UNKNOWN[WebUserDataPermission(javax.servlet.http.HttpServletRequest
request)]_

=== [#pgfId-658437]##

[#pgfId-658445]##
_link:jacc.html#UNKNOWN[WebUserDataPermission(java.lang.String
name, java.lang.String actions)]_

=== [#pgfId-658451]##

[#pgfId-658459]##
_link:jacc.html#UNKNOWN[WebUserDataPermission(java.lang.String
urlPatternSpec, java.lang.String[] HTTPMethods, java.lang.String
transportType)]_

=== [#pgfId-658465]##Methods

=== [#pgfId-658471]## boolean

[#pgfId-658479]##
_link:jacc.html#UNKNOWN[equals(java.lang.Object
o)]_

=== [#pgfId-658485]## _java.lang.String_

[#pgfId-658493]##
_link:jacc.html#UNKNOWN[getActions()]_

=== [#pgfId-658499]## int

[#pgfId-658507]##
_link:jacc.html#UNKNOWN[hashCode()]_

=== [#pgfId-658513]## boolean

[#pgfId-658521]##
_link:jacc.html#UNKNOWN[implies(java.security.Permission
permission)]_

[#pgfId-660839]##

[width="100%",cols="100%",options="header",]
|===
|[#pgfId-658526]##Inherited Member Summary
a|
=== [#pgfId-658530]##Methods inherited from class _Object_

|[#pgfId-658534]## _clone()_ , _finalize()_ , _getClass()_ , _notify()_
, _notifyAll()_ , _wait()_ , _wait(long)_ , _wait(long, int)_

a|
=== [#pgfId-658538]##Methods inherited from class _Permission_

|[#pgfId-658542]## _checkGuard(Object)_ , _getName()_ ,
_newPermissionCollection()_ , _toString()_
|===

=== [#pgfId-660841]##

image:authz-3.png[image]

Constructors

=== [#pgfId-660849]##[#marker-660843]##[#MemberHead]##[#javax.security.jacc.WebUserDataPermission.WebUserDataPermission(java.lang.String, java.lang.String)]##WebUserDataPermission( _java.lang.String_ name, _java.lang.String_ actions)

[#pgfId-660851]##public _WebUserDataPermission_ ( _java.lang.String_
name, _java.lang.String_ actions)

[#pgfId-660853]##Creates a new WebUserDataPermission with the specified
name and actions.

[#pgfId-660855]##The name contains a URLPatternSpec that identifies the
web resources to which the permissions applies. The syntax of a
URLPatternSpec is as follows:

[#pgfId-660857]## URLPatternList ::= URLPattern | URLPatternList colon
URLPattern

[#pgfId-660859]##

[#pgfId-660861]## URLPatternSpec ::= null | URLPattern | URLPattern
colon URLPatternList

[#pgfId-660863]##

[#pgfId-660865]##

[#pgfId-660867]##A null URLPatternSpec is translated to the default
URLPattern, “/”, by the permission constructor. The empty string is an
exact URLPattern, and may occur anywhere in a URLPatternSpec that an
exact URLPattern may occur. The first URLPattern in a URLPatternSpec may
be any of the pattern types, exact, path-prefix, extension, or default
as defined in the _Java Servlet Specification)_ . When a URLPatternSpec
includes a URLPatternList, the patterns of the URLPatternList identify
the resources to which the permission does NOT apply and depend on the
pattern type and value of the first pattern as follows:

* [#pgfId-660869]##No pattern may exist in the URLPatternList that
matches the first pattern.
* [#pgfId-660871]##If the first pattern is a path-prefix pattern, only
exact patterns matched by the first pattern and path-prefix patterns
matched by, but different from, the first pattern may occur in the
URLPatternList.
* [#pgfId-660873]##If the first pattern is an extension pattern, only
exact patterns that are matched by the first pattern and path-prefix
patterns may occur in the URLPatternList.
* [#pgfId-660875]##If the first pattern is the default pattern, “/”, any
pattern except the default pattern may occur in the URLPatternList.
* [#pgfId-660877]##If the first pattern is an exact pattern a
URLPatternList must not be present in the URLPatternSpec.

[#pgfId-660879]##The actions parameter contains a comma separated list
of HTTP methods that may be followed by a transportType separated from
the HTTP method by a colon.

[#pgfId-660881]## ExtensionMethod ::= any token as defined by RFC 2616

[#pgfId-660883]## (that is, 1*[any CHAR except CTLs or separators])

[#pgfId-660885]##

[#pgfId-660887]## HTTPMethod ::= "Get" | "POST" | "PUT" | "DELETE" |
"HEAD" |

[#pgfId-660889]## "OPTIONS" | "TRACE" | ExtensionMethod

[#pgfId-660891]##

[#pgfId-660893]## HTTPMethodList ::= HTTPMethod | HTTPMethodList comma
HTTPMethod

[#pgfId-660895]##

[#pgfId-660897]## HTTPMethodExceptionList ::= exclaimationPoint
HTTPMethodList

[#pgfId-660899]##

[#pgfId-660901]## HTTPMethodSpec ::= emptyString |
HTTPMethodExceptionList |

[#pgfId-660903]## HTTPMethodList

[#pgfId-660905]##

[#pgfId-660907]## transportType ::= "INTEGRAL" | "CONFIDENTIAL" | "NONE"

[#pgfId-660909]##

[#pgfId-660911]## actions ::= null | HTTPMethodSpec |

[#pgfId-660913]## HTTPMethodSpec colon transportType

[#pgfId-660915]##

[#pgfId-660917]##

[#pgfId-660919]##If duplicates occur in the HTTPMethodSpec they must be
eliminated by the permission constructor.

[#pgfId-660921]##An empty string HTTPMethodSpec is a shorthand for a
List containing all the possible HTTP methods.

[#pgfId-660923]##If the HTTPMethodSpec contains an
HTTPMethodExceptionList (i.e., it begins with an exclaimationPoint), the
permission pertains to all methods except those occuring in the
exception list.

[#pgfId-660925]##An actions string without a transportType is a
shorthand for a actions string with the value “NONE” as its
TransportType.

[#pgfId-660927]##A granted permission representing a transportType of
“NONE”, indicates that the associated resources may be accessed using
any conection type.

=== [#pgfId-660929]##Parameters:

[#pgfId-660931]## _name_ - the URLPatternSpec that identifies the
application specific web resources to which the permission pertains. All
URLPatterns in the URLPatternSpec are relative to the context path of
the deployed web application module, and the same URLPattern must not
occur more than once in a URLPatternSpec. A null URLPatternSpec is
translated to the default URLPattern, “/”, by the permission
constructor. All colons occuring within the URLPattern elements of the
URLPatternSpec must be represented in escaped encoding as defined in RFC
2396.

[#pgfId-660933]## _actions_ - identifies the HTTP methods and transport
type to which the permission pertains. If the value passed through this
parameter is null or the empty string, then the permission is
constructed with actions corresponding to all the possible HTTP methods
and transportType “NONE”.

=== [#pgfId-660941]##[#marker-660935]##[#MemberHead]##[#javax.security.jacc.WebUserDataPermission.WebUserDataPermission(java.lang.String, java.lang.String\[\], java.lang.String)]##WebUserDataPermission( _java.lang.String_ urlPatternSpec, _java.lang.String_ [] HTTPMethods, _java.lang.String_ transportType)

[#pgfId-660943]##public _WebUserDataPermission_ ( _java.lang.String_
urlPatternSpec, _java.lang.String_ [] HTTPMethods, _java.lang.String_
transportType)

[#pgfId-660945]##Creates a new WebUserDataPermission with name
corresponding to the URLPatternSpec, and actions composed from the array
of HTTP methods and the transport type.

=== [#pgfId-660947]##Parameters:

[#pgfId-660949]## _urlPatternSpec_ - the URLPatternSpec that identifies
the application specific web resources to which the permission pertains.
All URLPatterns in the URLPatternSpec are relative to the context path
of the deployed web application module, and the same URLPattern must not
occur more than once in a URLPatternSpec. A null URLPatternSpec is
translated to the default URLPattern, “/”, by the permission
constructor. All colons occuring within the URLPattern elements of the
URLPatternSpec must be represented in escaped encoding as defined in RFC
2396.

[#pgfId-660951]## _HTTPMethods_ - an array of strings each element of
which contains the value of an HTTP method. If the value passed through
this parameter is null or is an array with no elements, then the
permission is constructed with actions corresponding to all the possible
HTTP methods.

[#pgfId-660953]## _transportType_ - a String whose value is a
transportType. If the value passed through this parameter is null, then
the permission is constructed with actions corresponding to
transportType “NONE”.

=== [#pgfId-660961]##[#marker-660955]##[#MemberHead]##[#javax.security.jacc.WebUserDataPermission.WebUserDataPermission(javax.servlet.http.HttpServletRequest)]##WebUserDataPermission( _javax.servlet.http.HttpServletRequest_ request)

[#pgfId-660963]##public _WebUserDataPermission_ (
_javax.servlet.http.HttpServletRequest_ request)

[#pgfId-660965]##Creates a new WebUserDataPermission from the
HttpServletRequest object.

=== [#pgfId-660967]##Parameters:

[#pgfId-660969]## _request_ - the HttpServletRequest object
corresponding to the Servlet operation to which the permission pertains.
The permission name is the substring of the requestURI
(HttpServletRequest.getRequestURI()) that begins after the contextPath
(HttpServletRequest.getContextPath()). When the substring operation
yields the string “/”, the permission is constructed with the empty
string as its name. The constructor must transform all colon characters
occuring in the name to escaped encoding as defined in RFC 2396. The
HTTP method component of the permission’s actions is as obtained from
HttpServletRequest.getMethod(). The TransportType component of the
permission’s actions is determined by calling
HttpServletRequest.isSecure().

=== [#pgfId-660971]##

image:authz-3.png[image]

Methods

=== [#pgfId-660979]##[#marker-660973]##[#MemberHead]##[#javax.security.jacc.WebUserDataPermission.equals(java.lang.Object)]##equals( _java.lang.Object_ o)

[#pgfId-660981]##public boolean _equals_ ( _java.lang.Object_ o)

[#pgfId-660983]##Checks two WebUserDataPermission objects for equality.
WebUserDataPermission objects are equivalent if their URLPatternSpec and
(canonicalized) actions values are equivalent. The URLPatternSpec of a
reference permission is equivalent to that of an argument permission if
their first patterns are equivalent, and the patterns of the
URLPatternList of the reference permission collectively match exactly
the same set of patterns as are matched by the patterns of the
URLPatternList of the argument permission.

[#pgfId-660985]##Two Permission objects, P1 and P2, are equivalent if
and only if P1.implies(P2) && P2.implies(P1).

=== [#pgfId-660987]##Overrides:

=== [#pgfId-660989]## _equals_ in class _Permission_

=== [#pgfId-660991]##Parameters:

[#pgfId-660993]## _o_ - the WebUserDataPermission object being tested
for equality with this WebUserDataPermission.

=== [#pgfId-660995]##Returns:

[#pgfId-660997]##true if the argument WebUserDataPermission object is
equivalent to this WebUserDataPermission.

=== [#pgfId-661005]##[#marker-660999]##[#MemberHead]##[#javax.security.jacc.WebUserDataPermission.getActions()]##getActions()

[#pgfId-661007]##public _java.lang.String_ _getActions_ ()

[#pgfId-661009]##Returns a canonical String representation of the
actions of this WebUserDataPermission. The canonical form of the actions
of a WebUserDataPermission is described by the following syntax
description.

[#pgfId-661011]## ExtensionMethod ::= any token as defined by RFC 2616

[#pgfId-661013]## (that is, 1*[any CHAR except CTLs or separators])

[#pgfId-661015]##

[#pgfId-661017]## HTTPMethod ::= "GET" | "POST" | "PUT" | "DELETE" |
"HEAD" |

[#pgfId-661019]## "OPTIONS" | "TRACE" | ExtensionMethod

[#pgfId-661021]##

[#pgfId-661023]## HTTPMethodList ::= HTTPMethod | HTTPMethodList comma
HTTPMethod

[#pgfId-661025]##

[#pgfId-661027]## HTTPMethodExceptionList ::= exclaimationPoint
HTTPMethodList

[#pgfId-661029]##

[#pgfId-661031]## HTTPMethodSpec ::= emptyString |
HTTPMethodExceptionList |

[#pgfId-661033]## HTTPMethodList

[#pgfId-661035]##

[#pgfId-661037]## transportType ::= "INTEGRAL" | "CONFIDENTIAL" | "NONE"

[#pgfId-661039]##

[#pgfId-661041]## actions ::= null | HTTPMethodList |

[#pgfId-661043]## HTTPMethodSpec colon transportType

[#pgfId-661045]##

[#pgfId-661047]##

[#pgfId-661049]##If the permission’s HTTP methods correspond to the
entire HTTP method set and the permission’s transport type is “INTEGRAL”
or “CONFIDENTIAL”, the HTTP methods shall be represented in the
canonical form by an emptyString HTTPMethodSpec. If the permission’s
HTTP methods correspond to the entire HTTP method set, and the
permission’s transport type is not “INTEGRAL”or “CONFIDENTIAL”, the
canonical actions value shall be the null value.

[#pgfId-661051]##If the permission’s methods do not correspond to the
entire HTTP method set, duplicates must be eliminated and the remaining
elements must be ordered such that the predefined methods preceed the
extension methods, and such that within each method classification the
corresponding methods occur in ascending lexical order. The resulting
(non-emptyString) HTTPMethodSpec must be included in the canonical form,
and if the permission’s transport type is not “INTEGRAL” or
“CONFIDENTIAL”, the canonical actions value must be exactly the
resulting HTTPMethodSpec.

=== [#pgfId-661053]##Overrides:

=== [#pgfId-661055]## _getActions_ in class _Permission_

=== [#pgfId-661057]##Returns:

[#pgfId-661059]##a String containing the canonicalized actions of this
WebUserDataPermission (or the null value).

=== [#pgfId-661067]##[#marker-661061]##[#MemberHead]##[#javax.security.jacc.WebUserDataPermission.hashCode()]##hashCode()

[#pgfId-661069]##public int _hashCode_ ()

[#pgfId-661071]##Returns the hash code value for this
WebUserDataPermission. The properties of the returned hash code must be
as follows:

* [#pgfId-661073]##During the lifetime of a Java application, the
hashCode method shall return the same integer value every time it is
called on a WebUserDataPermission object. The value returned by hashCode
for a particular EJBMethod permission need not remain consistent from
one execution of an application to another.
* [#pgfId-661075]##If two WebUserDataPermission objects are equal
according to the equals method, then calling the hashCode method on each
of the two Permission objects must produce the same integer result
(within an application).

=== [#pgfId-661077]##Overrides:

=== [#pgfId-661079]## _hashCode_ in class _Permission_

=== [#pgfId-661081]##Returns:

[#pgfId-661083]##the integer hash code value for this object.

=== [#pgfId-661091]##[#marker-661085]##[#MemberHead]##[#javax.security.jacc.WebUserDataPermission.implies(java.security.Permission)]##implies( _java.security.Permission_ permission)

[#pgfId-661093]##public boolean _implies_ ( _java.security.Permission_
permission)

[#pgfId-661095]##Determines if the argument Permission is “implied by”
this WebUserDataPermission. For this to be the case all of the following
must be true:

* [#pgfId-661097]##The argument is an instanceof WebUserDataPermission.
* [#pgfId-661099]##The first URLPattern in the name of the argument
permission is matched by the first URLPattern in the name of this
permission.
* [#pgfId-661101]##The first URLPattern in the name of the argument
permission is NOT matched by any URLPattern in the URLPatternList of the
URLPatternSpec of this permission.
* [#pgfId-661103]##If the first URLPattern in the name of the argument
permission matches the first URLPattern in the URLPatternSpec of this
permission, then every URLPattern in the URLPatternList of the
URLPatternSpec of this permission is matched by a URLPattern in the
URLPatternList of the argument permission.
* [#pgfId-661105]##The HTTP methods represented by the actions of the
argument permission are a subset of the HTTP methods represented by the
actions of this permission.
* [#pgfId-661107]##The transportType in the actions of this permission
either corresponds to the value “NONE”, or equals the transportType in
the actions of the argument permission.

[#pgfId-661109]##URLPattern matching is performed using the _Servlet
matching rules_ where two URL patterns match if they are related as
follows:

* [#pgfId-661111]##their pattern values are String equivalent, or
* [#pgfId-661113]##this pattern is the path-prefix pattern “/*”, or
* [#pgfId-661115]##this pattern is a path-prefix pattern (that is, it
starts with “/” and ends with “/*”) and the argument pattern starts with
the substring of this pattern, minus its last 2 characters, and the next
character of the argument pattern, if there is one, is “/”, or
* [#pgfId-661117]##this pattern is an extension pattern (that is, it
starts with “*.”) and the argument pattern ends with this pattern, or
* [#pgfId-661119]##the reference pattern is the special default pattern,
“/”, which matches all argument patterns.

[#pgfId-661121]##All of the comparisons described above are case
sensitive.

=== [#pgfId-661123]##Overrides:

=== [#pgfId-661125]## _implies_ in class _Permission_

=== [#pgfId-661127]##Parameters:

[#pgfId-661129]## _permission_ - “this” WebUserDataPermission is checked
to see if it implies the argument permission.

=== [#pgfId-661131]##Returns:

[#pgfId-661133]##true if the specified permission is implied by this
object, false if not.

=== APPENDIX 

=== Related Documents

This specification refers to the following
documents. The terms used to refer to the documents in this
specification are included in brackets.

S. Bradner, “Key words for use in RFCs to
Indicate Requirement Levels,” RFC 2119, [Keywords] Harvard University,
March 1997

 _Java™ 2 Platform, Enterprise Edition
Specification Version 1.4_ [Java EE specification] Copyright 1999-2003,
Sun Microsystems, Inc. Available at _http://java.sun.com/j2ee/docs.html_
.

 _Java™ 2 Platform, Standard Edition, v1.4.0
API Specification_ [Java SE specification]. Copyright 1993-2003, Sun
Microsystems, Inc. Available at
_http://java.sun.com/j2se/1.4/docs/api/index.html_ .

 _Enterprise JavaBeans™ Specification, Version
2.1_ [EJB specification]. Copyright 1998-2003, Sun Microsystems, Inc.
Available at _http://java.sun.com/products/ejb_ .

 _Java™ Servlet Specification, Version 2.4_
[Servlet specification]. Copyright 1998-2003, Sun Microsystems, Inc.
Available at _http://java.sun.com/products/servlet_ .

 _Java™ Authentication and Authorization
Service_ (JAAS) 1.0 [JAAS specification]. Copyright 1999-2003, Sun
Microsystems, Inc. Available at _http://java.sun.com/products/jaas_ .

===  _ApPenDIX_ 

=== Issues

The following sections document the more
noteworthy issues that have been discussed by the Expert Group. These
sections are included in the Final Release as they provide insight into
the discussions and decisions which shaped the form of the current
specification. All of these issues have been resolved, and their
resolutions are described below and reflected in the document.

=== Configuration Context and Policy Context Identifiers

The PolicyConfiguration interface associates
Configuration Context Identifiers with policy statements, which
themselves contain embedded policy context identifiers. There needs to
be more explanation of the purpose and use models of these context
identifiers. Configuration context identifiers should only be assigned
by the Provider, to eliminate problems with ambiguity. In the case of
createRole, we allow a configuration context identifier to be passed to
createRole so that one configuration context id can be used for all of
the roles in an application/module. It would probably be a good idea to
allow the unchecked and excluded policy collections to also share the
same context id. This would reduce the complexity of the identity
mapping, but it would make it harder for the provider to ensure
uniqueness of identifiers. We also want to support deployment and
undeployment of modules, within a multi-module policy configuration
context. That is, the modules share the same roles, but their individual
policy statements are differentiated by policy context id within these
roles.



image:authz-4.png[image]

Regarding policy context identifiers, it will not be possible to
surgically replace the policy statements corresponding to a module, if
modules within a policy configuration context share the same policy
context identifiers.

image:authz-4.png[image]



image:authz-4.png[image]

The PolicyConfiguration interface has been redesigned to support both
the factory and finder patterns, and to include an inService method to
allow a container to check if a PolicyConfiguration with a given
identifier already exists. The interface also includes the concept of
linked PolicyConfigurations to identify those PolicyConfigurations that
must share the same principal-to-role mappings.

image:authz-4.png[image]

=== [[a780]]Configuration of Permissions with Parameters

The PolicyConfiguration interface is used to
communicate policy statements to Policy. An element of these statements
is a PermissionCollection that may contain EJBMethodPermission and
EJBRoleRefPermission objects that may have been constructed with
embedded references to argument arrays or EntityBean instances. The
contract must state whether such permissions may be passed through the
PolicyConfiguration interface, and what the responsibility of the
provider shall be should it occur.



image:authz-4.png[image]

resolved via the introduction of PolicyContext handlers and the
corresponding removal of the ability to include such information in
permission constrictions.

image:authz-4.png[image]

=== Extensibility of the PolicyConfiguration Interface

For example, the PolicyConfiguration
interface does not include methods that may be used to interrogate
Policy to determine the list of configured policy configuration
contexts. We should also consider whether the interface should be
extended to support the configuration of additional forms (other than
unchecked, and excluded) logical policy statements



image:authz-4.png[image]

(Partial) with the change to finder semantics, that is
getPolicyConfiguration, and the addition of the inService method to
PolicyConfigurationFactory.

image:authz-4.png[image]

=== Directory Scoped Extension matching patterns



image:authz-4.png[image]

We will not require that they be supported by policy providers, nor will
we require that policy providers reject other than the patterns defined
by servlet.

image:authz-4.png[image]

=== [[a788]]Evolution of Deployment Policy Language

The PolicyConfiguration and Policy Decision
Subcontracts should be generalized to sustain evolution in the
declarative authorization policy representations used in deployment
descriptors. One dimension of this evolution, would be a change from
DTDs to schema.



image:authz-4.png[image]

Some generalization in the PolicyConfiguration interface has occurred as
a result of the removal of policy context identifiers from permissions
such that any permission objects may be configured through this
interface.

image:authz-4.png[image]

=== [[a791]]Principals Passed to Providers in Subjects

The provider is expected to do
principal-to-role mapping, but we have not allowed the provider to
assume that it is working with a companion authentication module. We
have also not defined standard principals for containers to put in the
subjects used when they ask Policy to make decisions for them. So, it is
unclear how providers will be able to do Principal-to-Role mapping.



image:authz-4.png[image]

We decoupled consideration of this issue from notions of principal
selection imposed by the getCallerPrincipal and getUserPrincipal methods
of EJB and Servlet respectively. We clarified that all principals in an
AccessControlContext shall be available to the policy module for use in
principal to role mapping. We added a requirement with respect to
asserting or vouching authorities to ensure that principals
corresponding to authorities are not misinterpreted by providers as
principals of the subject (see link:jacc.html#a736[See Checking
the Caller for a Permission]). Moreover, we concluded that independent
of this contract, a policy module must be familiar with the principals
(i.e. security attributes) assigned to subjects as the result of
authentication in its operational environment and for which it must
evaluate policy.

image:authz-4.png[image]

=== [[a794]]Clarification of Servlet Constraint Matching Semantics

The definition of the security-constraint
matching and enforcement semantics are under specified in the Servlet
2.2 and 2.3 specifications. The contract defined in this document has
clarified these semantics; however there will be an issue until these
clarifications are incorporated in Servlet.



image:authz-4.png[image]

Servlet 2.4 specification will include a more complete description of
the processing of constraints.

image:authz-4.png[image]

=== [[a797]]References and Arguments in EJBMethodPermisison

When a container constructs an
EJBMethodPermission as part of its policy decision subcontract, it may
include a reference to the EJB (for an EntityBean) and the arguments to
the method in the constructed permission. Inclusion of this additional
context by containers is optional for performance reasons, yet it has
been suggested that the contract provide a way (perhaps via a callback
or an exception thrown by the provider) for the container to find out
whether or not such information would be used by the provider.



image:authz-4.png[image]

Resolved with introduction of policy context handlers

image:authz-4.png[image]

=== [[a800]]Permission Spanning in RoleRefPermission

The EJBRoleRefPermission and
WebRoleRefPermission objects support the checking of multiple
“references” in a single permission check. This functionality was
motivated by recurring requests to extend the Java EE “inRole” APIs to
allow multiple role references to be evaluated in a single call. The
permission classes noted above, currently support this functionality, at
the cost of having to span permissions in collection implication. The
most direct consequence of this spanning is that the new Permission
Collection methods of these Permission classes must not return null, as
they must return a PermissionCollection capable of doing the permission
specific spanning.



image:authz-4.png[image]

The replacement paradigm has been changed such that it should no longer
be possible for providers to depend on custom implementations of the
permission classes defined by this specification. Accordingly, the
complexity introduced by spanning should be attenuated in the reference
implementation.

image:authz-4.png[image]

=== [[a803]]Integrating Principal-to-Role Mapping with the Deployer Console

The desire for a single user interface for
security administration works somewhat counter to Java EE platforms that
provide their own administrative console for tasks like
principal-to-role mapping. That said, we need to preserve existing
platform administrative consoles by defining a method to integrate
provider specific principal-to-role mapping dialogs via the existing
platform consoles. We must ensure alignment with JSR 88, which is
solving a slightly different but overlapping problem. JSR 88 is defining
how a platform with fixed deployment interfaces can be integrated with
an administration console provided by another party.



image:authz-4.png[image]

This is optional functionality. Providers may choose to provide a JSR 88
config bean that encapsulates a provider specific principal-to-role
management interface. Containers that wish to have tight integration
between their deployment consoles and a provider supplied
principal-to-role management interface, should pass the provider
supplied config bean among the config beans they are required by JSR 88
to return to a deployment tool.

image:authz-4.png[image]

=== [[a806]]PolicyContext Identifiers are Unknown to Components

Although not strictly speaking within the
scope of this JSR, the work of this JSR empowers application components
to use the Java SE policy decision interface to perform their own access
control decisions. The permissions defined by this specification must be
constructed with an embedded policy context identifier so that the
policy provider can evaluate the permission in the proper deployment
context (i.e policy configuration). As currently defined, the
specification does not provide a component with access to its policy
configuration identifiers, and as such a component can not check any
permissions which implement the PolicyContext interface.



image:authz-4.png[image]

resolved by moving policy context identifiers out of the permissions,
into the PolicyContext utility class

image:authz-4.png[image]

=== [[a809]]JAAS Policy Interface expects Providers to be able to getPermissions

Not all Policy providers can, or find it
convenient or efficient, to determine all of the permissions granted to
an access control context. The JAAS Policy decision interface, and the
use of this interface by the JAAS SubjectDomainCombiner, impede the
integration of Policy Providers that are unable to enumerate all the
permissions that pertain to a subject/protection domain before returning
from _Policy.getPermissions()_ .



image:authz-4.png[image]

Added requirement to link:jacc.html#a173[See Provider
Configuration Subcontract] that the
_javax.security.auth.SubjectDomainCombiner_ of a J2EE 1.3 application
server must _combine_ into the permission collection returned by
_javax.security.auth.Policy.getPermisions_ . Recommended same of J2EE
1.4 application servers.

image:authz-4.png[image]

=== [[a812]]Implementing Web Security Constraints as Permission

Specification of the WebResourcePermission
and WebUserDataPermission classes with simple, single URL pattern names
is a bad fit for the Java SE Policy decision interface. The
implementation of getPermissions presents a major challenge, as the
constraint model would force the implementation to preserve ungranted
constraining permissions in the returned PermissionCollection. It also
would not be possible to implement the enumeration functionality
available through the elements method of the collection. Perhaps more
significant, the mapping of security constraints to simple, single URL
pattern names would require a special more complex Policy provider rule
combining algorithm, and as such, would render the default Java Policy
provider incompetent to process such permissions. The last point is in
direct conflict with a stated goal of the specification.



image:authz-4.png[image]

The translation of web security constraints into Java SE permissions was
modified such that the URL pattern names of the WebResource and
WebUserData permissions include a representation of the URL patterns to
which the permission does NOTapply. The permission implies logic was
enhanced to take this change into account. As a result of these changes
these permissions may be processed by the default Java SE Policy module
like any other Java SE permission.

image:authz-4.png[image]

=== [[a815]]Exception Handling

The first PFD did not define error handling
for the methods of the PolicyConfigurationFactory and PolicyContext
classes, or for the PolicyConfiguration and PolicyContextHandler
interfaces. Also, no provision was provided for implementation classes
to pass checked exceptions out through the defined interfaces and
classes.



image:authz-4.png[image]

A PolicyContextException class was added to the javax.security.jacc
package, and the methods of the classes and interfaces identified above
were modified to throw this checked exception as appropriate.

image:authz-4.png[image]

=== [[a818]]PolicyConfiguration Commit

The first PFD did not provide a way for
container deployment tools to indicate when the translation of a policy
context was complete and available for assimilation into the associated
Policy provider. It had been assumed that the Policy.refresh method
could serve this purpose, until it was discovered that depending on
Policy.refresh for this purpose would preclude parallelism in the
deployment of applications.



image:authz-4.png[image]

Added "commit" and “inService” methods to the PolicyConfiguration
interface, and formalized a 3 state (i.e. open, inService, and deleted)
life cycle for policy contexts. Required that the commit method be
called on a PolicyConfiguration object after all of its policy
statements have been added, and after it is "linked to any other module
with which it must share the same principal-to-role mapping". Also
required that Policy.refresh only assimilate policy contexts in the
“inService” state.

image:authz-4.png[image]

=== [[a821]]Support for ServiceEndpoint methodInterface

The definition of the EJBMethodPermission
class in the first PFD did not support “ServiceEndpoint" as a valid
methodInterface value. The ServiceEndpoint methodInterface was
introduced by EJB 2.1.



image:authz-4.png[image]

Added “ServiceEndpoint” as another possible value for the
methodInterface component of an EJBMethodPermission methodNameSpec.

image:authz-4.png[image]

=== [[a824]]TypeNames of EJBMethodPermission Array Parameters

The syntax or syntaxes that may be used to
specify array parameters are not defined by the constructors of the
EJBMethodPermission class. The corresponding canonical form of such
params as returned by getActions must also be specified.



image:authz-4.png[image]

Added requirement that Array parameters be specified as ComponentType[]
as apposed to in the form returned by Class.getName() (i.e.
[LComponentType;).

image:authz-4.png[image]

=== [[a827]]Checking Permission on the root of a Web Application

The URLPattern, "/", cannot be used to check
a permission, as it is a synonym for asking if permission to access the
entire application has been granted.



image:authz-4.png[image]

Require that the empty string be used as a replacement for "/", during
the permission evaluation. Clarify the WebResourcePermission and
WebUserDataPermission definitions to account for the use of the
empty-string as a legitimate URLPattern in such permissions.

image:authz-4.png[image]

=== [[a830]]Calling isUserInRole from JSP not mapped to a Servlet

Checking a WebRoleRefPermission requires the
name of a Servlet to identify the scope of the reference to role
translation. The name of a scoping servlet has not been established for
an unmapped JSP.



image:authz-4.png[image]

For every security role in the web application add a
WebRoleRefPermission to the corresponding role. The name of all such
permissions shall be the empty string, and the actions of each
permission shall be the corresponding role name. When checking a
WebRoleRefPermission from a Web resource not mapped to a servlet, use a
permission with the empty string as its name and with the argument to
isUserInRole as its actions.

image:authz-4.png[image]

=== [[a833]]Support for HTTP Extension Methods

Servet 2.5 added support for HTTP extension
methods (as defined in IETF RFC 2616 "Hypertext Transfer Protocol --
HTTP/1.1") to security-constraints. Support for extension methods
requires changes to the WebResourcePermission and WebUserDataPermission
classes and to the translation of servlet security-constraints. In
general support for HTTP extension methods requires an ability to
represent non-enumerable HTTP method sets in the HTTPMethodSpec
components of WebResourcePermission and WebUserDataPermission actions
values.



image:authz-4.png[image]

Modified the HTTPMethodSpec constructs of WebResourcePermission and
WebUserDataPermission to support an HTTPMethodExceptionList as a third
form of HTTPMethodSpec. This resolution is known to have the following
consequences with respect to backward compatibility: 1) A permission
constructed with an HTTPMethodSpec composed of an HTTPMethodList
containing all the "standard" HTTP methods (i.e.,
"DELETE,GET,HEAD,OPTIONS,POST,PUT,TRACE) is no longer equal to and no
longer implies a permission constructed with a null, empty array, or
emptyString HTTPMethodSpec. 2) Permissions constructed with a null,
empty array, or emptyString HTTPMethodSpec component to their actions
value represent the non-enumerable (due to extension methods) set of all
possible HTTP methods and are NOT equal to or implied by any permission
constructed with an HTTPMethodSpec represented as an HTTPMethodList. 3)
It is no longer possible to use the HTTPMethodList syntax to represent
(via enumeration) the complement of a proper subset of all HTTP methods.
As such, an HTTPMethodExceptionList must be used to represent any proper
subset of HTTP methods determined NOT to be constrained during the
translation of servlet security-constraints. 4) The use of exception
lists causes the permissions resulting from the translation of a given
security-constraint configuration to differ in their actions values from
those that would have been produced prior to support for HTTP extension
methods. Previously translated permissions remain supported by the
changed permission implementations, and (with the exceptions listed in 1
and 2 above) continue to function as they did before the change, as long
as extension methods are not set in checked permissions.

image:authz-4.png[image]

=== [[a836]]Welcome File and security-constraint Processing

The relationship between welcome file
processing (which can modify the effective request URI) and
security-constraint processing is not defined by the Servlet
Specification. Since this specification uses url-patterns derived from
request URIs to name target resources in checked permissions, it is
important that welcome file processing and its relationship to
security-constraint processing be clearly specified. Without a clear
description of this relationship, unprotected request URIs which are
modified to yield effective request URIs for protected resources may
inadvertently be left unprotected.



image:authz-4.png[image]

pending Servlet clarification. Recommend that Servlet standarize an
HttpServletRequest attribute that can be used to portably obtain the
requestURI following welcome file mapping. Once this attribute is
standardized, The HttPservletRequest based constructors of
WebResourcePermission and WebUserDataPermission would use its value to
establish the permission name.

image:authz-4.png[image]

=== [[a839]]Colons Within path-segment of Request URI

As defined in IETF RFC 2396 "Uniform Resource
Identifiers (URI): Generic Syntax", the abs_path component of a request
URI may consist of a sequence of "/" separated path segments, where the
format of each segment is defined as follows:

=== segment = *pchar *( ";" param )

param = *pchar

=== pchar = unreserved | escaped |":" | "@" | "&" | "=" | "+" | "$" | ","

A colon character occurring within a
path-seqment will be syntactically indistinguishable from colons used by
the WebResourcePermission and WebUserDataPermission constructors to
demarcate qualifying patterns.



image:authz-4.png[image]

Require that containers use escaped encoding (as defined in RFC 2396) on
colon characters occuring within url-patterns obtained from web.xml.
Also require that containers encode colons occuring within patterns
extracted from HttpServletRequest objects and used to create the names
of checked WebResourcePermission and WebUserDataPermission objects. Also
require the the HttpServletRequest based constructors of
WebResourcePermission and WebUserDataPermission apply escaped encoding
to colons occuring in the names the derived from the request URI. Note
that the colon character is represented as %3A in escaped encoding.

image:authz-4.png[image]

===  aPPENDIX

=== Revision History



=== Community Draft Version 0.3 (dated 12/13/2001)

Posted for Community Review 12/17/2001

=== Changes in Public Draft Version 0.1

=== General

JCP version changed to 2.1.

Specification title changed to J2EETM
Authorization Contract for Containers

Added additional definitions to the terminology
section for link:jacc.html#a90[See JAAS Policy interface]” and
link:jacc.html#a92[See JAAS Policy provider]”.

Converted the requirements with respect to
support for this specification on J2EE 1.3 and 1.4 platforms into
assumptions, as any such requirements will ultimately be defined in the
J2EE 1.4 Platform Specification.

Added an Assumption and a corresponding
requirement with respect to support for Policy Providers that get all
permissions before returning from Policy.

Clarified relationship to Servlet and EJB
specification of authorization semantics.

Changed all references to “VM” to “JRE”

Changed all references to “deploy tool” to
“deployment tool”

Removed empty brackets from all method names in
prose.

=== Changes to Provider Configuration Subcontract

Rewrote replacability paradigm. New model does
not require replacement of permission implementations.

Described changes to JAAS SubjectDomainCombiner
as required when contract is optionally applied in a J2EE 1.3 context.

=== Changes to Policy Configuration Subcontract

Changed to be compatible with the changes made
(for replacability) to the link:jacc.html#a173[See Provider
Configuration Subcontract]”.

=== Changes to Policy Decision Subcontract

Added section describing
link:jacc.html#a703[See Component runAs Identity]” to
distinguish between runAs identity and caller identity. More accurately
described what a container must do to set a component’s runAs identity.
Added requirement that container prevent component from being able to
modify its runAs identity.

Added clarification of the matching of an
excluded policy statement to a granted permission.

Clarified the policy decision algorithms in
link:jacc.html#a727[See Checking AccessControlContext
Independent Grants]” and link:jacc.html#a736[See Checking the
Caller for a Permission]” to be compatible with the distinction between
caller and runAs identity. Also factored out references to platform
versions.

In link:jacc.html#a736[See Checking
the Caller for a Permission]” added requirement that caller identity not
include principals of any trusted (other than the caller).

Added new section,
link:jacc.html#a745[See Missing Policy Contexts]”, to make
explicit the behavior of a provider when asked to check a permission in
an unknown policy context.

Rewrote the link:jacc.html#a750[See
Policy Compatibility Requirements]” to indicate that a J2EE 1.4
container that uses a JAAS policy interface to perform container access
decisions would not be compatible with this specification.

=== Changes to API

Changed PolicyConfigurationFactory to be an
abstract class with a static method that reads a system property to
instantiate a concrete factory implementation class. Also documented the
role of PolicyConfigurationFactory in supporting the PolicyConfiguration
with null context identifier.

Specified exceptions to be thrown by methods of
PolicyConfiguration interface.

Changed the PolicyConfiguration interface to
support the configuration of permissions that are not instances of
PolicyContext into a PolicyConfiguration with null identifier.

=== Changes to Issues

{empty}Resolved issue
link:jacc.html#a791[See Principals Passed to Providers in
Subjects]

{empty}Resolved issue
link:jacc.html#a800[See Permission Spanning in
RoleRefPermission]

{empty}Added new issue
link:jacc.html#a803[See Integrating Principal-to-Role Mapping
with the Deployer Console]

{empty}Added new Issue
link:jacc.html#a806[See PolicyContext Identifiers are Unknown
to Components]

=== Changes in Public Draft Version 0.2

=== General

Specification title changed to JavaTM
Authorization Contract for Containers

Corrected audience to be the public

In terminology: simplified definition of
redeploy, corrected definition of provider, by removing permission
implementations, as these will now be part of application server
platform.

=== Changes to Provider Configuration Subcontract

 Replaced most references to container with
JRE, as a provider integrates per JRE.

=== Changes to Policy Decision Subcontract

In link:jacc.html#a624[See EJB Policy
Decision Semantics], replace references to “subject” with “access
control context”.

In link:jacc.html#a703[See Component
runAs Identity], softened requirement that container prevent component
from modifying its runAs identity by saying that this must be the
default policy.

Changes references to “access exception” to
AccessControlException.

=== Changes to Issues

Added Introductory paragraph.

Added new issue,
link:jacc.html#a809[See JAAS Policy Interface expects Providers
to be able to getPermissions] and its resolution to ensure that this
issue is documented.

=== Changes in Proposed Final Draft 1 Expert Draft 0.1

=== General

The license page was changed; most notably the
license number.

Improper uses of the word “which” were replaced
with the word “that”.

The word “shall” was replaced with the word
“must”.

The 2.3 version designation was removed from
references to Servlet as the applicable Servlet release is defined by
the EE environment.

=== Changes to the Preface and Overview

The preface was changed to reflect the purpose
of the PFD

the definition of hostname was modified so that
hostnames are no longer required to be used in servlet policy context
identifiers.

The requirement that permissions identify the
context of their use was changed to require that the context be set
before permission evaluation.

=== Changes to Provider Configuration Subcontract

link:jacc.html#a184[See PolicyContext
Class and Context Handlers] was inserted to describe the PolicyContext
utility class and the PolicyContextHandler interface.

link:jacc.html#a196[See What the
Application Server Must Do] was modified to include the application
server’s responsibilities relating to the PolicyContext class, and to
correct errors in the names of the abstract policy classes.

=== Changes to Policy Configuration Subcontract

The examples in
link:jacc.html#a235[See What a Java EE Platform’s Deployment
Tools Must Do], were modified to reflect changes to policy context
identifiers and their removal from permission names.

{empty}The requirement that the names of
checked permissions identify the policy context was removed from
link:jacc.html#a253[See Policy Contexts and Policy Context
Identifiers]

{empty}The linkConfiguration method name
replaced the incorrect link method name in
link:jacc.html#a269[See Linking Policy Contexts]

link:jacc.html#a271[See Servlet Policy
Context Identifiers] was moved to follow
link:jacc.html#a269[See Linking Policy Contexts], and the
section was made less prescriptive with respect to the format of Servlet
policy context identifiers. The non-normative description of the
behavior of the Tomcat server was removed.

link:jacc.html#a281[See Translating
security-constraint Elements] was made a subsection of a new
link:jacc.html#a276[See Translating Servlet Deployment
Descriptors] and changed to deal with the removal of policy context
identifiers from permission names.

The part of the translation remaining in
link:jacc.html#a281[See Translating security-constraint
Elements] was modified to yield an OR constraint combination semantic.

{empty}The description of the mapping of
transport guarantees to unacceptable connection types was moved to a new
link:jacc.html#a330[See Mapping Transport Guarantee to
Connection Type]

link:jacc.html#a343[See Translating
Servlet security-role-ref Elements] was modified to reflect the removal
of policy context identifiers from permission names.

link:jacc.html#a518[See Translating
EJB method-permission Elements] was made a subsection of a new
link:jacc.html#a516[See Translating EJB Deployment Descriptors]
and changed to deal with the removal of policy context identifiers from
permission names.

A new section link:jacc.html#a512[See
EJB Policy Context Identifiers], was added to describe the selection of
EJB policy context identifiers.

link:jacc.html#a518[See Translating
EJB method-permission Elements], link:jacc.html#a521[See
Translating the EJB exclude-list], and link:jacc.html#a524[See
Translating EJB security-role-ref Elements] were all changed to reflect
the removal of the policy context identifier from permission names.

link:jacc.html#a533[See Undeploying an
Application or Module] was modified to reflect the use of the
PolicyContext class to define the policy context.

link:jacc.html#a549[See Permission to
Configure Policy] was changed to require that “the state of the policy
statement repository” not be changed when the caller does not have the
“setPolicy” permission. Also a new requirement was added that policy be
configured to grant containers the “getPolicy” and “setPolicy”
permissions.

=== Changes to Policy Decision Subcontract

The name was changed to the “Policy Decision
and Enforcement Contract”.

link:jacc.html#a563[See Evaluation of
Transport Guarantees], link:jacc.html#a569[See Pre-dispatch
Decision], and link:jacc.html#a572[See Application Embedded
Privilege Test] were changed to reflect the removal of the policy
context identifier from permission names.

Section 4.2.1 “Servlet Constraint Matching
Semantics”, was replaced by two sections;
link:jacc.html#a576[See Servlet Policy Decision Semantics], and
link:jacc.html#a595[See WebResourcePermission Matching Rules].
The latter describes the processing of servlet constraints in a manner
related to the three types of policy statements created via the
PolicyConfiguration interface.

Section 4.2.2.1, “Servlet URL-Pattern Matching
Rules” was renamed.

Some changes were made to the last two tables
of Section 4.2.2.2, “Servlet Constraint Matching Examples” to
accommodate and better illustrate the OR constraint combining semantics.

Section 4.2.3, “WebRoleRefPermission Processing
Semantics” was added as the public draft mistakenly assumed that the
Servlet policy model was just about constraints.

link:jacc.html#a616[See EJB
Pre-dispatch Decision] and link:jacc.html#a620[See EJB
Application Embedded Privilege Test] were changed to reflect the removal
of the policy context identifier from permission names.

A new link:jacc.html#a707[See Setting
the Policy Context] was added to describe how a container must set the
policy context before invoking policy. This section also requires that
containers be granted the setPolicy permission in all policy contexts.

A new link:jacc.html#a710[See Policy
Context Handlers] was added to define the requirements on containers
with respect to policy context handlers. The following new sections were
added to define the policy context handlers required of containers:
link:jacc.html#a715[See Container Subject Policy Context
Handler], link:jacc.html#a719[See SOAPMessage Policy Context
Handler], link:jacc.html#a721[See HttpServletRequest Policy
Context Handler], link:jacc.html#a723[See EnterpriseBean Policy
Context Handler], and link:jacc.html#a725[See EJB Arguments
Policy Context Handler].

The methods for checking policy as defined in
link:jacc.html#a727[See Checking AccessControlContext
Independent Grants] were reorganized such that it is clear that one of
the presented alternatives must be used. Using
AccessController.checkPermission was added as an additional supported
alternative, and the release specific techniques were annotated as such.
Also the techniques based on getPermissions were annotated as not
recommended. At the end of the section a requirement was made regarding
the policy context having been set prior to the evaluation.

The same changes as described in the previous
change item were applied to link:jacc.html#a736[See Checking
the Caller for a Permission].

link:jacc.html#a745[See Missing Policy
Contexts] was renamed from “Unconfigured Policy Contexts” and the
semantics were modified to reflect the use of the PolicyContext utility
class and the designation of the null policy context id as the default.

A new link:jacc.html#a747[See Default
Policy Context] was introduced to describe requirements for chaining
policy evaluation through to the provider of the default policy context.

=== Changes to API

Replaced the PolicyContext interface with the
PolicyContext class. Also changed all of the permissions such that none
of them implement the PolicyContext interface and such that none of them
include a policy context identifier in their names.

Added the PolicyContextHandler interface.

Removed the special purpose, EntityBean and
Argument array constructors from the EJBMethodPermission class.

Removed the special purpose, EntityBean
constructor from the EJBRoleRefPermission class.

Modified the actions field of the
EJBRoleRefPermission and WebRoleRefPermission classes such that they
contain at most a single role reference. Related to this change, also
removed the newPermissionCollection method implementation from both of
these classes.

In the PolicyConfiguration interface, changed
the name of the getPolicyContextId method to getContextID.

Changed the description of the
PolicyConfigurationFactory to require implementation classes to have a
public no argument constructor. Also precluded the use of the null value
as an argument to getPolicyConfiguration.

Added a new constructor to the
WebResourcePermission and WebUserDataPermission classes to allow an
instance to be constructed from an HttpServletRequest.

=== Changes to Issues

Changed the introductory material to indicate
that all of the issues have been resolved.

The resolution of Issue
link:jacc.html#a780[See Configuration of Permissions with
Parameters], was changed to reflect the introduction of policy context
handlers.

Issue link:jacc.html#a788[See
Evolution of Deployment Policy Language], was partially resolved by
removing the requirement that permissions added via the
PolicyConfiguration interface have policy context identifiers in their
names.

Issue link:jacc.html#a794[See
Clarification of Servlet Constraint Matching Semantics], was resolved
with the rewrite of Section link:jacc.html#a595[See
WebResourcePermission Matching Rules], and with the expectation that the
Servlet EG will adopt a change to section SRV.12.8 of the Servlet
specification.

Issue link:jacc.html#a797[See
References and Arguments in EJBMethodPermisison], was resolved with the
introduction of policy context handlers.

Issue link:jacc.html#a803[See
Integrating Principal-to-Role Mapping with the Deployer Console], was
made optional functionality.

Issue link:jacc.html#a806[See
PolicyContext Identifiers are Unknown to Components], was resolved by
introducing the PolicyContext utility class.

=== Changes in Proposed Final Draft 1 Expert Draft 0.2

=== Changes to the Preface and Overview

The restriction that entities be identified by
principal was removed from the definition of grant.

=== Changes to Policy Configuration Subcontract

In link:jacc.html#a235[See What a Java
EE Platform’s Deployment Tools Must Do], the argument to
linkConfiguration was corrected in the example.

=== Changes to Policy Decision Subcontract

Section 4.2.2.1, “Servlet URL-Pattern Matching
Rules” was modified to indicate that pattern length only is significant
among path prefix matches.

A description of the content of the tables and
how they should be interpreted was added to Section 4.2.2.2, “Servlet
Constraint Matching Examples”.

Section 4.2.3, “WebRoleRefPermission Processing
Semantics” was added as the public draft mistakenly assumed that the
Servlet policy model was just about constraints.

link:jacc.html#a616[See EJB
Pre-dispatch Decision] and link:jacc.html#a572[See Application
Embedded Privilege Test] were changed to reflect the removal of the
policy context identifier from permission names.

=== Changes to History

The history section was completed to reflect
the changes made in Version 0.1 and 0.2

=== Changes in Proposed Final Draft 1 Expert Draft 0.3

=== Changes to the Preface and Overview

The requirement that applicable constraints be
selected by best-match was rephrased to define best-match as it is
defined in this spec and the Servlet specification.

=== Changes to Policy Configuration Subcontract

A clarifying sentence was added to the end of
link:jacc.html#a544[See What the Provider Must Do] to make it
clear that this specification does not prescribe the policy language or
the methods used within providers to implement the defined policy and
role requirements.

=== Changes to Policy Decision Subcontract

Section 4.2.3, “WebRoleRefPermission Processing
Semantics” was simplified, as much of its content was not pertinent to
the WebRoleRefPermission class.

Section 4.4.2, “EJB Permission Matching Rules”
was changed to reflect the change to a single role in the actions of the
EJBRoleRefPermission class.

In link:jacc.html#a715[See Container
Subject Policy Context Handler], the key for the "Subject Policy Context
Handler" was changed to javx.security.auth.Subject.container, and the
semantics were modified to return the caller or runAs identity as
appropriate.

In link:jacc.html#a723[See
EnterpriseBean Policy Context Handler], the handler return type was
corrected.

=== Changes to API

The resolution of the class diagram was
improved by changing to a black and white image.

=== Changes in Proposed Final Draft 2 Expert Draft 1

=== General

In many places through out the document,
replaced used of the phrase “policy configuration” with “policy
context”, and adopted the practice of using PolicyConfiguration to refer
to the configuration interface of a policy context.

=== Changes to Preface

Updated Status section

Acknowledged all contributors, including RI and
TCK team, and all those who commented on the specification.

=== Changes to Overview

Added dashed lines to
link:jacc.html#a76[See Policy Configuration and Enforcement
Subcontracts]to represent PolicyContext interactions.

Modified requirement 7, to reflect change is
treatment of permissions derived from security-constraints.

=== Changes to Provider Configuration Subcontract

Added two new sentences to the end of
link:jacc.html#a175[See Policy Implementation Class], to make
it clear that this contract is dependent on the standard Java Policy
replacement mechanisms, and to make it clear that containers must
support replacability.

In link:jacc.html#a196[See What the
Application Server Must Do], added all elements of the jacc package to
the list of things that an application server must bundle.

In link:jacc.html#a196[See What the
Application Server Must Do], the requirement for
javax.security.auth.Policy replacement was softened such that it only
applies to 1.3 application servers that choose to support this
specification.

In link:jacc.html#a196[See What the
Application Server Must Do], reintroduced the requirement that setPolicy
not be called again, to ensure more than temporary Policy replacement.

=== Changes to Policy Configuration Subcontract

In the examples in
link:jacc.html#a235[See What a Java EE Platform’s Deployment
Tools Must Do], the type of the declared permission was corrected to
agree with constructed type, and “petID” was changed to “petContextID”
(as a clarification).

In the examples in
link:jacc.html#a235[See What a Java EE Platform’s Deployment
Tools Must Do], a new stanza was added to place the policy context in
service.

link:jacc.html#a257[See Policy Context
Life Cycle], was added.

In link:jacc.html#a276[See Translating
Servlet Deployment Descriptors], the call to getPolicyConfiguration was
augmented with a second parameter to ensure that all policy statements
are removed from the context.

link:jacc.html#a281[See Translating
security-constraint Elements], was rewritten such that the target names
of the WebResourcePermission and WebUserDataPermission policy statements
resulting from the translation are qualified such that they precisely
specify the resources to which they apply. The most significant affect
of this change is that it captures the best-matching semantics of the
Servlet constraint model in the permission names, such that these
permissions can be tested using the standard J2SE permission evaluation
logic.

Added a new section,
link:jacc.html#a288[See Qualified URL Pattern Names]”, to
describe the rules for composing the target names used in the
construction of the WebResourcePermission and WebUserDataPermission
policy statements resulting from the translation of Servlet security
constraints.

The section that had described the “Mapping to
Unacceptable Transport Connection Types” was changed to describe the
mapping to “acceptable” connection type. The title of the section was
changed to link:jacc.html#a330[See Mapping Transport Guarantee
to Connection Type]”. link:jacc.html#a332[See
transport-guarantee to Acceptable Connection Mapping] was also changed
to reflect the change to “acceptable” connection types, and the
connection type values in the table were modified to agree with the
transportTypeSpec syntax of the WebUserDataPermission class.

link:jacc.html#a347[See Servlet
URL-Pattern Matching Rules], was added to support the pattern
qualification section, and relevant sections of the enforcement
subcontract.

link:jacc.html#a354[See Example] was
added

In link:jacc.html#a516[See Translating
EJB Deployment Descriptors], the call to getPolicyConfiguration was
augmented with a second parameter to ensure that all policy statements
are removed from the context.

The last paragraph of
link:jacc.html#a521[See Translating the EJB exclude-list], was
clarified.

link:jacc.html#a527[See Deploying an
Application or Module], link:jacc.html#a533[See Undeploying an
Application or Module], link:jacc.html#a536[See Deploying to an
existing Policy Configuration], and link:jacc.html#a540[See
Redeploying a Module], were all changed o reflect the introduction of
the policy context life cycle and the commit method.

The inService method was added to the factory
methods called out in the first paragraph of
link:jacc.html#a549[See Permission to Configure Policy], and
the SecurityPermission required by these methods was changed from
“getPolicy” to “setPolicy” to correct an inconsistency with the Java
implementation.

=== Changes to Policy Decision and Enforcement Subcontract

link:jacc.html#a558[See Policy
Enforcement by Servlet Containers], was modified to require that
containers use Policy to make access control decisions.

link:jacc.html#a563[See Evaluation of
Transport Guarantees], was modified to describe how the transport type
value is obtained for the permission construction, and to reflect the
change made to the WebUserDataPermission class such that it is no longer
checked by “determining if a Permission has been excluded”.

link:jacc.html#a563[See Evaluation of
Transport Guarantees], and link:jacc.html#a569[See Pre-dispatch
Decision], were changed to reference the error processing defined in the
Servlet specification.

link:jacc.html#a576[See Servlet Policy
Decision Semantics], was rewritten to reflect the qualification of the
permission names, and the change to conventional permission evaluation
semantics.

link:jacc.html#a595[See
WebResourcePermission Matching Rules], link:jacc.html#a601[See
WebRoleRefPermission Matching Rules], and
link:jacc.html#a607[See WebUserDataPermission Matching Rules]
were added to define the permission specific matching semantics
necessary to support the policy decision semantics.

Section 4.2.2.1, “Servlet URL-Pattern Matching
Rules”, Section 4.2.2.2, “Servlet Constraint Matching Examples”, and
Section 4.2.3, “WebRoleRefPermission Processing Semantics” were removed
from the document, as the change to qualified pattern names made these
sections unnecessary.

link:jacc.html#a614[See Policy
Enforcement by EJB Containers], was modified to require that containers
use Policy to make access control decisions.

link:jacc.html#a624[See EJB Policy
Decision Semantics], was replaced with a simplified section that
references link:jacc.html#a576[See Servlet Policy Decision
Semantics].

link:jacc.html#a627[See
EJBMethodPermission Matching Rules], and
link:jacc.html#a697[See EJBRoleRefPermission Matching Rules],
were added to define the permission specific matching semantics
necessary to support the policy decision semantics. These new sections
replaced Section 4.4.2, “EJB Permission Matching Rules”.

The last paragraph of
link:jacc.html#a703[See Component runAs Identity], was modified
to ensure that the AccessControlContext includes a
SubjectDomainCombiner.

In link:jacc.html#a710[See Policy
Context Handlers], changed the last sentence of the paragraph to “...if
these actions will cause the container to fail in its processing of the
associated request”.

In link:jacc.html#a715[See Container
Subject Policy Context Handler] replaced “caller’s identify” with
“caller’s identity”.

In link:jacc.html#a719[See SOAPMessage
Policy Context Handler], reduce to only EJB container, and added
additional qualification of the request coming in at the ServiceEndpoint
method interface.

In link:jacc.html#a725[See EJB
Arguments Policy Context Handler], clarified that this handler may not
be used if the request came in on the ServiceEndpoint method interface.
Also changed the return type when there are no arguments to an empty
array.

Renamed section
link:jacc.html#a727[See Checking AccessControlContext
Independent Grants] and changed it to reflect the changes made to
WebUserDataPermissions such that they are no longer “excluded”
permissions.

In link:jacc.html#a745[See Missing
Policy Contexts], changed replaced contains with inService method.

=== Changes to API

A new class diagram was imported to reflect the
changes to the API, most notably the introduction of the
PolicyContextException class.

The javadocs were regenerated to conceal
implementation specific private instance variables.

Added “ServiceEndpoint” to the list of
alternative MethodInterface identifiers for EJBMethodPermissions.

More completely specified EJBMethodPermission
matching of methodNameSpec in implies

Added policy context life cycle, including
description, and state table to PolicyConfiguration interface.

Added new methods “commit” and inService to the
PolicyConfiguration interface.

Changed all the method signatures of the
PolicyConfiguration interface to throw PolicyContextException, and
described the other exceptions that implementations are required to
throw.

Changed the documentation of
getPolicyConfigurationFactory to properly identify the system property.

Added a new parameter to the
getPolicyConfiguration method of PolicyConfigurationFactory to indicate
whether or not all the policy statements should be removed from the
policy context.

Renamed contains of PolicyConfigurationFactory
class to inService.

Changed all the method signatures of the
PolicyConfigurationFactory class to throw PolicyContextException, and
described the other exceptions that implementations are required to
throw.

Changed authorization requirement of the
PolicyContext class to allow containers to be responsible for deciding
how callers of this method must be authorized.

Changed the getContext and registerHandler
methods of the PolicyContext class to declare that they throw
PolicyContextException., and described the other exceptions that these
methods are required to throw.

Changed the format of the name used to
construct a WebResourcePermission to contain a URLPatternSpec, and
described the restrictions on the patterns appearing in the
URLPatternList.

Modified the specification of the implies and
equals methods of WebResourcePermission to account for the
URLPatternSpec.

Changed the format of the name used to
construct a WebUserDataPermission to contain a URLPatternSpec, and
described the restrictions on the patterns appearing in the
URLPatternList.

Changed BNF for “actions” of
WebUserDataPermission such that a separating “:” is not required if a
transportType is not explicitly specified.

Replaced transportTypeList in actions of
WebuserdataPermission with a single transportType value.

Modified the specification of the implies and
equals methods of WebUserDataPermission to account for the
URLPatternSpec.

Comparable Interface was removed from
WebResourcePermission and WebUserDataPermission.

description of the second clause of the
“servlet matching rules” of WebResourcePermission.implies and
WebUserDataPermission.implies were changed to properly reflect the
servlet matching semantics; where for example, /a/b/* must match /a/b in
addition to /a/b/z.

In WebUserDataPermission constructor removed
extra “and” in “...by calling and HttpServletRequest.isSecure()”.

In description of
PolicyContextHandler.getContext, removed extra “the” from “and obtain
from it the the”.

=== Changes to References

Upgraded document version references for [J2EE
specification], [J2SE specification], [EJB specification], and [Servlet
specification] to 1.4, 1.4.0, 2.1, and 2.4 respectively. Also updated
URL for [J2EE specification].

=== Changes to Issues

Added new issue,
link:jacc.html#a812[See Implementing Web Security Constraints
as Permission].

Added new issue,
link:jacc.html#a815[See Exception Handling].

Added new issue,
link:jacc.html#a818[See PolicyConfiguration Commit].

Added new issue,
link:jacc.html#a821[See Support for ServiceEndpoint
methodInterface].

=== Changes in Proposed Final Draft 2 Expert Draft 2

=== Changes to Preface

fixed typos, and added additional RI team
member to credits.

=== Changes to Policy Configuration Subcontract

In link:jacc.html#a347[See Servlet
URL-Pattern Matching Rules], added additional clause to support
universal matching by “/*”.

In link:jacc.html#a354[See Example],
Added comments to security-constraint elements, Also corrected qualified
URL Pattern Names occurring in link:jacc.html#a399[See
Qualified URL Pattern Names from Example] and
link:jacc.html#a416[See Permissions and PolicyConfiguration
Operations from Example].

In link:jacc.html#a527[See Deploying
an Application or Module], changed the text of the footnote to properly
reflect that policy contexts are linked by object not by identifier.

=== Changes to Policy Decision and Enforcement Subcontract

In link:jacc.html#a563[See Evaluation
of Transport Guarantees], and link:jacc.html#a569[See
Pre-dispatch Decision], changed the corresponding construction
descriptions to be less prescriptive such that calling any constructor
that results in the proper name being established would be allowed. Also
indicated that the resulting url-pattern is to be “unqualified”.

Modified link:jacc.html#a576[See
Servlet Policy Decision Semantics], to require that the policy
statements of the default policy context be included in the access
decisions and to require that the subject based policy statements be
tested when the status is unresolved following the excluded and
unchecked evaluations.

Added a new link:jacc.html#a579[See
Matching Qualified URL Pattern Names] to describe URLPatternSpec
matching, and replaced the duplicate descriptions of this processing in
sections link:jacc.html#a595[See WebResourcePermission Matching
Rules] and link:jacc.html#a607[See WebUserDataPermission
Matching Rules] with a reference to this new section. Also modified the
description of the comparison to support symmetric implication as
necessary to support consistent semantics between the implies and equals
methods of these permissions.

Added requirement that the comparisons defined
by link:jacc.html#a595[See WebResourcePermission Matching
Rules], link:jacc.html#a601[See WebRoleRefPermission Matching
Rules], link:jacc.html#a607[See WebUserDataPermission Matching
Rules], link:jacc.html#a627[See EJBMethodPermission Matching
Rules], and link:jacc.html#a697[See EJBRoleRefPermission
Matching Rules] be case sensitive.

The word “form” was changed to “from” in first
paragraph of link:jacc.html#a727[See Checking
AccessControlContext Independent Grants].

In bullets 4 and 5 of
link:jacc.html#a727[See Checking AccessControlContext
Independent Grants], removed “that was constructed without static
permissions and”.

Rewrote link:jacc.html#a747[See
Default Policy Context] to indicate describe the properties of the
default policy context, and to require that its policy statements be
included in every access decision.

=== Changes to API

comments on HttpServletRequest based
constructors for WebResourcePermission and WebUserDataPermission were
changed so as not to imply that this is the only constructor that may be
used by a container “prior to checking” a Servlet request.

the description of the implies method of
WebResourcePermission and WebUserDataPermission was modified to support
the maxim that two permission objects p1 and p2 are equivalent iff
p1.implies(p2) and p2.implies(p1). To do so required handling the case
where the name of the argument permission (to implies) is a qualified
URLPatternSpec.

the description of the servlet matching rules
in the implies method of WebResourcePermission and WebUserDataPermission
was corrected to account for universal matching by “/*”.

=== Changes in Proposed Final Draft 2 Expert Draft 3

=== Changes to Policy Configuration Subcontract

Added a new first paragraph to
link:jacc.html#a281[See Translating security-constraint
Elements], to describe the treatment of patterns overridden by and made
irrelevant by the presence of the “/*” pattern in the a
web-resource-collection within the deployment descriptor.

Moved the last paragraph in
link:jacc.html#a288[See Qualified URL Pattern Names]” to be its
first, and added a new paragraph to its end to describe irrelevant
patterns and their treatment by the permission constructors. Clarified
the syntax and description of URLPattern qualification. Indicated that
patterns qualified by other qualifying patterns may be dropped from the
list of qualifying patterns (and described why).

In link:jacc.html#a354[See Example],
removed the “/*” pattern from the first web-resource-collection of the
first security constraint, and made the corresponding changes to the
table of qualified URL pattern names and the table of constructed
permissions.

Added a new column to
link:jacc.html#a399[See Qualified URL Pattern Names from
Example] of link:jacc.html#a354[See Example] to represent the
canonical form of the qualified names.The description of
link:jacc.html#a416[See Permissions and PolicyConfiguration
Operations from Example] was modified to indicate that the names in its
second column were obtained from the first column of
link:jacc.html#a399[See Qualified URL Pattern Names from
Example], and that any equivalent form of the qualified names, including
their canonical forms, could have been used in the permission
constructions.

=== Changes to Policy Decision and Enforcement Subcontract

In link:jacc.html#a563[See Evaluation
of Transport Guarantees], clarified the actions value used for a request
that arrives on an unprotected connection.

=== Changes to API

The URLPatternList descriptions of the
WebResourcePermission and WebUserDataPermission classes; were modified
to require that no pattern in a URLPatternList may imply the first
pattern of the URLPatternSpec, as otherwise the URLPatternSpec could not
imply itself which would violate the required equals semantics.

The definition of the equals method of the
WebResourcePermission and WebUserDataPermission classes; was modified
such that different URLPatternList values are equal if the lists imply
the same patterns.

=== Changes in Proposed Final Draft 2 Expert Draft 4

=== Changes to API

The serialization (see Serialized Form on html
Javadocs) of the javax.security.jacc permission classes was described
more completely and to remove unnecessary constraints on
implementations.

The canonical forms produced by the getActions
methods of the WebResourcePermission and WebUserDataPermission classes
were more completely specified.

=== Changes in Final Release

=== Changes to License

License was replaced

=== Changes to the Preface

The preface was changed to reflect the purpose
of the Final Release.

Additional contributor names were added.

=== Changes to Overview

Added requirement to support
link:jacc.html#a736[See Checking the Caller for a Permission],
to ensure that policy providers not place extra requirements on
containers.

=== Changes to Provider Configuration Subcontract

Added another catch clause to the code sample
in link:jacc.html#a196[See What the Application Server Must
Do], to support verification that the loaded object is an instanceof
javax.security.Policy.

=== Changes to Policy Configuration Subcontract

Added definition of what it means for two
translations to be “equivalent” to link:jacc.html#a235[See What
a Java EE Platform’s Deployment Tools Must Do].

Added clarification to
link:jacc.html#a281[See Translating security-constraint
Elements] to allow for “equivalent” translations.

Restated the translation description of
link:jacc.html#a281[See Translating security-constraint
Elements], such that it no longer prescribes the number of permissions
that must be constructed.

Modified the title of the second column of
link:jacc.html#a332[See transport-guarantee to Acceptable
Connection Mapping].

Restated the translation description of
link:jacc.html#a343[See Translating Servlet security-role-ref
Elements], such that it no longer is as prescriptive with respect to the
“construction” of permissions, and such that it defines the name to use
for the “additional” permissions.

Fixed a syntax problem, missing "<" in
"urlPattern>", in link:jacc.html#a354[See Example].

Changed some of the actions values of
link:jacc.html#a416[See Permissions and PolicyConfiguration
Operations from Example], such that they are all in canonical form.
Added table footnote to that effect.

Added clarification to
link:jacc.html#a518[See Translating EJB method-permission
Elements] to allow for “equivalent” translations.

Restated the translation description of
link:jacc.html#a518[See Translating EJB method-permission
Elements], such that it no longer such that it no longer prescribes the
number of permissions that must be constructed.

Clarified the linking requirements of
link:jacc.html#a527[See Deploying an Application or Module] and
of link:jacc.html#a540[See Redeploying a Module].

In link:jacc.html#a533[See Undeploying
an Application or Module], link:jacc.html#a536[See Deploying to
an existing Policy Configuration], and in
link:jacc.html#a540[See Redeploying a Module], changed “must
stop accepting” to “must stop dispatching” requests.

=== Changes to Policy Decision and Enforcement Contract

Added special rule for checking "/" to
link:jacc.html#a563[See Evaluation of Transport Guarantees],
and link:jacc.html#a569[See Pre-dispatch Decision].

In link:jacc.html#a563[See Evaluation
of Transport Guarantees], link:jacc.html#a569[See Pre-dispatch
Decision], link:jacc.html#a572[See Application Embedded
Privilege Test], link:jacc.html#a616[See EJB Pre-dispatch
Decision], and link:jacc.html#a620[See EJB Application Embedded
Privilege Test], changed the description of how the checked permission
is "obtained".

Added clarification of "the scope of a
containers processing of a component request" to
link:jacc.html#a710[See Policy Context Handlers].

Added a clarification to
link:jacc.html#a710[See Policy Context Handlers], allowing
containers to delay the registration of the required handlers.

In link:jacc.html#a723[See
EnterpriseBean Policy Context Handler], restricted the use of this
handler to the business method of the EJB Remote, Local, or
ServiceEndpoint interfaces of the EnterpriseBean object.

Added a footnote to
link:jacc.html#a736[See Checking the Caller for a Permission],
to clarify why calling Policy.getPermissions is not recommended.

Added link:jacc.html#a753[See
Optimization of Permission Evaluations] to describe the circumstances
under which containers may caching the results of permission
evaluations.

=== Changes to API

Added package description

Changed MethodSpec and constructor descriptions
of EJBMethodPermission to provide support for additional method-intf
values.

Clarified the syntax of typeName as used in
methodParams of EJBMethodPermission. Also specified the corresponding
affect on the canonical form returned by getActions.

For both WebResourcePermission nd
WebUserDataPermission, specified the effect of constructing these
permissions with a null name. Also clarified that the empty string is a
supported exact pattern.

For both WebResourcePermission nd
WebUserDataPermission, corrected definition of HttpServletRequest based
constructors such that they obtain the permission name from the
RequestURI minus the contextPath, except for the special case where the
name would be "/", in which case the empty string is used as the
permission name.

In WebUserDataPermission, Fixed errors in the
BNF for transportType.

Added text to javadoc of JACC permission
classes to make it clear that these permissions may implement
newPermissionCollection or inherit its implementation from their
superclass.

Modified the definition of the PolicyContext
class to allow for implementations that restrict access to the security
sensitive methods of this utility class without necessarily resorting to
checking the setPolicy SecurityPermission.

=== Changes to Appendix A: Related Documents

Updated the copyright dates.

=== Changes to Appendix B: Issues

Added descriptions of 3 new issues:
link:jacc.html#a824[See TypeNames of EJBMethodPermission Array
Parameters], link:jacc.html#a827[See Checking Permission on the
root of a Web Application], and link:jacc.html#a830[See Calling
isUserInRole from JSP not mapped to a Servlet].

=== Changes in Errata A

=== Changes to Policy Configuration Subcontract

Page 24: added requirement to
link:jacc.html#a343[See Translating Servlet security-role-ref
Elements]" for extra WebRoleRefPermission objects to be created to
support calls to isUserInRole from unmapped JSPs.

=== Changes to Policy Enforcement Subcontract

Page 37: added requirement to
link:jacc.html#a572[See Application Embedded Privilege Test]"
to support calling isUserInRole from an unmapped (to servlet) web
resource.

page 47: added footnote to
link:jacc.html#a736[See Checking the Caller for a Permission]"
to act as a forward reference to optimization by reuse of
unauthenticated results as allowed for by new text added to
link:jacc.html#a753[See Optimization of Permission
Evaluations]". This optimization allows a container to optimize
authorization checks on unprotected resources.

Page 50: added new clarifying text to
link:jacc.html#a753[See Optimization of Permission
Evaluations]" to support performance optimization based on reuse of
evaluation results. In addition to reuse of equivalent evaluations,
added text to support reuse of unauthenticated evaluations to authorize
evaluations independent of caller identity. Described a common practice
that could be implemented by containers and providers, and that would
cause containers to be notified by providers of policy changes. By
following the suggested practice providers would be able to tell when
containers expect to be notified, for containers to determine if they
will be notified, and for containers to determine if their provider has
other properties necessary to sustain reuse.

=== Changes to API

Page 87: Clarified Description of
WebRoleRefPermission class.

Page 88: Modified description of name parameter
of WebRoleRefPermission constructor to describe use of empty-string
name.

=== Changes to Appendix B: Issues

Page 105: removed sentence from description of
resolution of issue B19, link:jacc.html#a830[See Calling
isUserInRole from JSP not mapped to a Servlet]", that had indicated that
the resolution would NOT be adopted until the Servlet spec was changed.
As a result of this errata, the resolution to issue B19 has been fully
integrated.

=== Changes in Errata B

=== Changes to Overview

Page 7: modified requirement 9 to allow for and
describe the circumstances under which a container may run without a
SecurityManager.

Page 8: added link:jacc.html#a154[See
Running Without a SecurityManager] to describe the changes to this
contract that apply to containers running without a J2SE
SecurityManager.

=== Change log for Errata C

=== Changes Made Throughout the Document

Changed the "J2EE" and "J2SE" platform names
(when not used with a specific version such as J2EE 1.4) to "Java EE"
and "Java SE" respectively.

Changed improper uses of "affect" to "effect".

=== Changes to Overview

In link:jacc.html#a120[See
Assumptions]", clarified assumptions 1 and 3 to indicate that contract
is intended to apply and be required by future versions of the Java EE
platform.

=== Changes to Provider Configuration Contract

Generalized the J2EE 1.4 version specific
requirements such that they also apply to later versions of the EE
platform.

=== Changes to Policy Configuration Contract

Extended the chapter abstract to indicate that
the subcontract applies to the configuration of policy providers from
authorization rules defined within Java code using common annotations.

In link:jacc.html#a235[See What a Java
EE Platform’s Deployment Tools Must Do] and 18, described the deployment
tool requirements relating to annotation processing, and the merging of
annotations into the deployment descriptor such that the translation may
occur using the deployment descriptor translation rules.

In link:jacc.html#a271[See Servlet
Policy Context Identifiers], described why each module of a multi-module
web application must be deployed to a separate policy context.

In link:jacc.html#a343[See Translating
Servlet security-role-ref Elements], clarified that the set of all roles
defined for the application is used to determine the additional
permissions to be constructed.

In link:jacc.html#a512[See EJB Policy
Context Identifiers], added rule to ensure that no two EJBs in a policy
context share the same ejb-name. If this rule is not observed the policy
statements for the EJBs would be inappropriately combined.

=== Changes to Policy Decision and Enforcement Contract

Inserted new section
link:jacc.html#a560[See Permission Names for Transport and
Pre-Dispatch Decisions], to call attention to the description of how the
corresponding permissions names are constructed. This section was
intended to account for the welcome file processing defined by the
Servlet specification. The corresponding clarification of the
relationship between welcome file processing and servlet-constraint
processing was not made to the Servlet spec, so, consistent with the
assumptions under which this spec. was defined, clarifying semantics
will not be prescribed by this spec. until they are adopted by the
Servlet specification.

Revised section
link:jacc.html#a563[See Evaluation of Transport Guarantees] and
section link:jacc.html#a569[See Pre-dispatch Decision], to
refer to the newly inserted section for the definition of their
respective permission names.

Added new sentence the description of the
link:jacc.html#a723[See EnterpriseBean Policy Context Handler]
to account for EJB 3.0 Session and Entity beans which are not required
to implement the javax.ejb.EnterpriseBean interface.

=== Changes to API

On page 69, clarified the description of the
PolicyConfiguration.commit() method to indicate that it also throws an
UnsupportedOperationException when completing the commit would cause
there to be two or more inService and linked policy contexts with
different principal-to-role mappings.

Changes to the description of the
HttpServletRequest based constructors of the WebResourcePermission and
WebUserDataPermission intended to clarify that welcome file processing
must have been performed before permission construction were deferred
pending clarification of the corresponding functionality in the Servlet
Specification

=== Change log for Errata D

=== Changes Made Throughout the Document

Changed The specification version from 1.0 to
1.1

=== Changes to Policy Configuration Contract

Amended link:jacc.html#a281[See
Translating security-constraint Elements] to support the translation of
security-constraints containing extension methods as defined in IETF RFC
2616 "Hypertext Transfer Protocol -- HTTP/1.1".

Added a new subsection,
link:jacc.html#a318[See HTTP Method Exception List]", to
describe the representation of non-enumerable HTTP method subsets as
necessary, for example, to identify all methods not named in a
security-constraint.

Modified the actions entries in Table 3-4:
"Permissions and PolicyConfiguration Operations from
Example" to conform to the translation changes required to support
non-enumerable http extension methods.

=== Changes to Policy Decision and Enforcement Contract

Inserted new link:jacc.html#a589[See
Matching HTTP Method Specifications] to describe the HTTPMethodSpec as
revised (by the definition of the HTTPMethodExceptionList) to support
HTTP extension methods.

Modified link:jacc.html#a595[See
WebResourcePermission Matching Rules] and
link:jacc.html#a607[See WebUserDataPermission Matching Rules]
to refer to the new section describing the matching of HTTP method
specifications.

=== Changes to API

Modified the WebResourcePermission class to
support HTTP extension methods. Extended the permission's actions syntax
to represent HTTP method exception lists so that non-enumerable method
subsets can be represented in the permission's actions. Exception lists
are used to represent unconstrained http method subsets.

Modified the WebUserDataPermission class to
support HTTP extension methods. Extended the permission's actions syntax
to represent HTTP method exception lists as was done for the
WebResourcePermission class.

=== Changes to Appendix B: Issues

Added new issue
link:jacc.html#a833[See Support for HTTP Extension Methods].
Resolution describes consequences with respect to backward
compatibility:

Added new issue
link:jacc.html#a836[See Welcome File and security-constraint
Processing] to describe the need for clarification of the relationship
between welcome file processing, which can change the effective request
URI, and the url-patterns applied in security-constraint processing.

Added new issue
link:jacc.html#a839[See Colons Within path-segment of Request
URI] to document the potential ambiguity resulting from the use, by the
WebResourcePermission and WebUserDataPermission classes, of the colon
character to distinguish qualifying patterns.

=== Change log for Errata E

=== Changes Made Throughout the Document

Changed the specification version from 1.1 to
1.2

=== Changes to Overview

In link:jacc.html#a136[See
Requirements]", clarified requirement 4 to indicate that a policy
provider in a Servlet or EJB only container need only satisfy the
requirements corresponding to the supported container.

Corrected bullet 3 of
link:jacc.html#a154[See Running Without a SecurityManager]", by
removing prohibition on AccessControlContext.checkPermission.

Added new bullet 4 to
link:jacc.html#a154[See Running Without a SecurityManager]", to
ensure that container sets AccessControlContext if it uses the
AccessController.checkPermission technique.

Added new section,
link:jacc.html#a160[See Servlet or EJB only containers], to
differentiate requirements that must be satisfied by web containers from
those that must be satisfied by EJB containers.

=== Changes to Policy Configuration Contract

in link:jacc.html#a235[See What a
Java EE Platform’s Deployment Tools Must Do], modified the definition of
equivalence to accept as equivalent a translation in which permissions
that are implied by excluded permissions are removed from the role and
unchecked permission collections. Limited the definition of equivalence
to apply only to those permission types that are the subject of the
translation. Added footnote to describe why equivalence cannot always be
evaluated by PermissionCollection.implies().

in link:jacc.html#a276[See
Translating Servlet Deployment Descriptors] and in
link:jacc.html#a516[See Translating EJB Deployment
Descriptors], relaxed requirement that the value true be passed as the
second argument to getPolicyConfiguration. Changed text to require that
the policy statements be removed, and added footnotes to describe
implementation choices.

added a requirement to
link:jacc.html#a288[See Qualified URL Pattern Names], that the
translation use escaped encoding to differentiate colons occurring
within the Pattern and QualifyingPattern elements from those used to
construct the QualifyingPatternList.

Corrected determination of permission name in
link:jacc.html#a524[See Translating EJB security-role-ref
Elements] such that the name is acquired from the ejb-name of the
element containing the security-role-ref.

Added a new paragraph in
link:jacc.html#a524[See Translating EJB security-role-ref
Elements] to describe the creation of additional EJBRoleRefPermission
objects to support optional declaration of security-role-ref elements
(as required by the EJB 3.0 specification)

Added a footnote to
link:jacc.html#a524[See Translating EJB security-role-ref
Elements] to indicate that the requirements of this section apply to any
elements that are permitted by the EJB deployment descriptor schema to
contain security-role-ref elements. This was done in anticipation of
support for inclusion of this element in the message-driven element

=== Changes to Policy Decision and Enforcement Contract

In link:jacc.html#a560[See Permission
Names for Transport and Pre-Dispatch Decisions], added the requirement
that all colon characters occurring within the name of the checked
permission be represented using escaped encoding.

In link:jacc.html#a616[See EJB
Pre-dispatch Decision] corrected requirement that an
RMISecurityException be thrown by requiring that the container throw an
exception as required by the corresponding EJB Specification.

Added footnote to
link:jacc.html#a710[See Policy Context Handlers] to make it
explicit that the requirement that a handler return a null value when
called outside of the context of an invocation, need not apply to any
additional handlers registered with the container.

Modified the requirements of
link:jacc.html#a710[See Policy Context Handlers] to allow
containers to effectively delay registrations that would otherwise
impede performance. As a result of the change, containers (especially
EJB containers) may return null when, during the processing of a
request, an attempt is made to invoke a required but not yet registered
handler.

In link:jacc.html#a727[See Checking
AccessControlContext Independent Grants] corrected return result of
AccessController.checkPermission when exception is not thrown.

In link:jacc.html#a750[See Policy
Compatibility Requirements]. corrected the reference to the
_javax.security.auth.Policy.getPolicy_ method.

=== Changes to API

Added requirement to the HttpServletRequest
based constructors of WebResourcePermission and WebUserDataPermission
that the constructors must transform all colon characters occurring in
the name to escaped encoding.

Added requirement that all colons occurring
within the URLPattern elements of the name and URLPatternSpec arguments
passed to the String based constructors of WebResoucePermission and
WebUserDataPermission must be represented in escaped encoding.

=== Changes to Issues

Added recommended resolution to issue,
link:jacc.html#a836[See Welcome File and security-constraint
Processing].

Added resolution to issue,
link:jacc.html#a839[See Colons Within path-segment of Request
URI].

=== Change log for Errata F

=== Changes Made Throughout the Document

Changed the specification version from 1.2 to
1.3.

=== Changes to Policy Configuration Subcontract

in link:jacc.html#a281[See
Translating security-constraint Elements], modified the translation to
handle http-method-omission elements introduced by servlet 3.0.

added new link:jacc.html#a302[See
Combining HTTP Methods], to define the combination of http-method and
http-method-omission elements, and to describe the translation of the
results to the actions string used to construct WebResourcePermission
and WebUserDataPermission objects.

In link:jacc.html#a354[See Example],
modified the excluding auth constraint to demonstrate the use of an
http-method-omission list. Also changed link:jacc.html#a416[See
Permissions and PolicyConfiguration Operations from Example] to contain
the corresponding translation.

In link:jacc.html#a524[See
Translating EJB security-role-ref Elements], added an example in a
footnote.

=== Change log for Errata G (maintenance Release 7)

=== Changes Made Throughout the Document

Changed the specification version from 1.3 to
1.4.

Changed the JCP version to 2.7

=== Changes to Policy Configuration Subcontract

In link:jacc.html#a253[See Policy
Contexts and Policy Context Identifiers], added a footnote to describe
exceptional case of EJBs bundled within a WAR.

In link:jacc.html#a271[See Servlet
Policy Context Identifiers], added paragraph to ensure that EJBs defined
in web modules are assigned to a separate policy context to ensure that
the EJBcontext can be put in service before the policy context of the
web module (which may depend on being able to call the EJB) . Also added
a footnote with reference to section link:jacc.html#a512[See
EJB Policy Context Identifiers] for further clarification.

Added link:jacc.html#a278[See
Programmatic Servlet Registrations], to describe how the servlet policy
translation defined by this subcontract can be applied to the security
configuration resulting from the programmatic registration and security
configuration enabled by Servlet 3.0. Also added a description of how an
existing policy context may be retranslated while presrving its links to
other policy contexts.

In link:jacc.html#a512[See EJB Policy
Context Identifiers], added paragraph to ensure that EJBs defined in web
modules are assigned to a separate policy context to ensure that the EJB
context can be put in service before the policy context of the web
module (which may depend on being able to call the EJB).

Clarified link:jacc.html#a527[See
Deploying an Application or Module], to allow translations, links, and
commits of individual modules to be interleaved as necessary to support
runtime initialization of servlet policy (as required by Servlet 3.0)
while preserving the ability of a ServletContextListener to make a local
call to an EJB in the same application (and without getting an access
exception).

In the optional
link:jacc.html#a536[See Deploying to an existing Policy
Configuration], added an additional paragraph to describe what must be
done to capture the effects of any programmatic registrations and
security configurations that may happen during initialization in a
Servlet 3.0 container.

Simplified link:jacc.html#a540[See
Redeploying a Module], by having it refer to
link:jacc.html#a527[See Deploying an Application or Module],
which, as described above, has been changed to handle Servlet 3.0.

=== Changes to API

Added clarification to removeUncheckedPolicy,
removeExcludedPolicy, and removeRole methods (of the PolicyConfiguration
interface) to indicate that these methods have no effect on the linkages
among policy contexts.

Added requirement that the removeRole method
of the PolicyConfiguration interface remove all roles when called with a
role name of "*" and when no role by that name exists in the
PolicyConfiguration..

Added clarification to the
getPolicyConfiguration method of PolicyConfigurationFactory to indicate
that it removes policy statements and linkages when the value of the
remove parameter is true.

=== Change log for Errata H(maintenance Release 8)

=== Changes Made Throughout the Document

Changed the specification version from 1.4 to
1.5.

updated the license page

=== Changes to Policy Configuration Subcontract

In link:jacc.html#a278[See
Programmatic Servlet Registrations], changed reference to Servlet 3.0 to
"beginning with Servlet 3.0".

In link:jacc.html#a281[See
Translating security-constraint Elements], added text to describe the
handling of the role-name "**" in an auth-constraint, and to indicate
that the "*" role does not imply the "**" role unless the application
has defined its own role named "**". Amended description of permissions
created for uncovered methods, to require that they be added to either
the excluded or unchecked permission collections, based on the uncovered
method semantic in effect for the web-module.

In link:jacc.html#a343[See
Translating Servlet security-role-ref Elements], and
link:jacc.html#a524[See Translating EJB security-role-ref
Elements], added description of the handling of the "any authenticated
user" role "**".

In link:jacc.html#a518[See
Translating EJB method-permission Elements], ammended description of the
translation of role-names in method-permission elements, to include
support for the role named "**".

In link:jacc.html#a544[See What the
Provider Must Do], added requirement that the provider grant all
permissions assigned to role "**" to any authenticated user.

=== 

'''''

[.footnoteNumber]# 1.# [[a1250]]For some permission
types, such as the EJBMethodPermission, it will generally not be
possible to use the implies method of the PermissionCollection to
compute collection equivalence (because the implies method is unable to
determine when a collection contains all the permissions implied by a
wild carded form of the permission).

[.footnoteNumber]# 2.# [[a1251]]An exception to this
rule is described in link:jacc.html#a512[See EJB Policy Context
Identifiers]”.

[.footnoteNumber]# 3.# [[a1252]]See
link:jacc.html#a512[See EJB Policy Context Identifiers]” for
further clarification.

[.footnoteNumber]# 4.# [[a1253]]This can be achieved
by passing _true_ as the second parameter in the call to
_getPolicyConfiguration_ , or by calling _delete_ on the
PolicyConfiguration before calling _getPolicyConfiguration_ to
transition it to the open state.

[.footnoteNumber]# 5.# [[a1254]]The
WebUserDataPermission objects allow a container to determine when to
reject a request before redirection if it would ultimately be rejected
as the result of an excluding _auth-constraint_ .

[.footnoteNumber]# 6.# [[a1255]] _The value null
should be used as the actions value in the construction of a
WebUserDataPermission when_ both _the HTTP method specification, and the
representation of the acceptable connection type may be represented by
null. If only one of the action components may be represented by null
the other should be used as the actions value._

[.footnoteNumber]# 7.# [[a1256]]The set of all
possible HTTP methods is non-enumerable and contains the traditional
HTTP methods (i.e., DELETE, GET, HEAD, OPTIONS, POST, PUT, TRACE) and
any method conforming to the “extension-method” syntax defined in IETF
RFC 2616 “Hypertext Transfer Protocol -- HTTP/1.1”. A null or the
emptyString HTTP method specification is used to this set.

[.footnoteNumber]# 8.# [[a1257]]Qualifying patterns
implied by another qualifying pattern may be dropped because the use of
the reduced list to qualify a pattern will yield a URLPatternSpec
“equal” to the URLPatternSpec produced by qualifying the pattern with
the full list (for example, /a/*:/a/b:/a/b/*:/a/b/c/* is equal to
/a/*:/a/b/*).

[.footnoteNumber]# 9.# [[a1258]]See
link:jacc.html#a839[See Colons Within path-segment of Request
URI] for details.

[.footnoteNumber]# 10.# [[a1259]]These additional
WebRoleRefPermission objects support the use of isUserInRole from
unmapped (to a Servlet) JSP components.

[.footnoteNumber]# 11.# [[a1260]]The canonical form
for the set of all HTTP Methods (including all extension methods) is
null.

[.footnoteNumber]# 12.# [[a1261]]This can be achieved
by passing _true_ as the second parameter in the call to
_getPolicyConfiguration_ , or by calling _delete_ on the
PolicyConfiguration before calling _getPolicyConfiguration_ to
transition it to the open state.

[.footnoteNumber]# 13.# [[a1262]]EJB 3.0 supports
inclusion of security-role-ref elements in entity and session elements.
Future versions could support inclusion in message-driven.

[.footnoteNumber]# 14.# [[a1263]]For example, if an
application declares roles \{R1, R2, R3} and defines a session EJB named
“shoppingCart” that contains one security-role-ref __ element with
role-name R1, then an additional EJBRoleRefPermission must be added to
each of the roles R2 and R3. The name of both permissions must be
“shoppingCart”, and the actions value of the permission added to role R2
must be “R2”, and the actions value of the permission added to role R3
must be “R3”.

[.footnoteNumber]# 15.# [[a1264]]Policy context
linking is transitive and symmetric, and this specification should not
be interpreted as requiring that linkConfiguration be called on every
combination of policy contexts that must share the same
principal-to-role mapping, or that all contexts must be linked before
any can be committed.

[.footnoteNumber]# 16.# [[a1265]]Such as having a
Servlet 3.0 ServletContextListener configured that could
programmatically register a servlet and configure its security
constraints and that could also perform a local invocation of an EJB in
another module of the application.

[.footnoteNumber]# 17.# [[a1266]]The
HttpServletRequest based constructors of WebResourcePermission and
WebUserDataPermission must perform the escaped ecoding. For all other
constructors, the encoding must be performed prior to invoking the
constructor. See issue link:jacc.html#a839[See Colons Within
path-segment of Request URI].

[.footnoteNumber]# 18.# [[a1267]]The syntax and
semantics of an HTTPMethodExceptionList are described in a subsection of
link:jacc.html#a281[See Translating security-constraint
Elements]”.

[.footnoteNumber]# 19.# [[a1268]]Whether or not this
requirement applies to an additional PolicyContextHandler depends on the
definition of the handler.

[.footnoteNumber]# 20.#
link:jacc.html#a753[See Optimization
of Permission Evaluations]" allows containers to reuse granted results
obtained for unauthenticated callers (i.e. with no principals) to
authorize, independent of caller identity, permissions implied by such
results.

[.footnoteNumber]# 21.# [[a1270]]Not all policy
systems support this query. Also, the Policy provider does not see the
permission being checked, and therefore cannot use the permission to
identify when to invoke a particular policy context handler.
